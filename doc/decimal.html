
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2018 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>decimal.decimal - D Programming Language</title>

<link rel="stylesheet" href="https://dlang.org/css/codemirror.css">
<link rel="stylesheet" href="https://dlang.org/css/style.css">
<link rel="stylesheet" href="https://dlang.org/css/print.css" media="print">
<link rel="shortcut icon" href="https://dlang.org/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='decimal.decimal' class='std'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="https://dlang.org/images/dlogo.svg"></a></div>
    <a href="https://dlang.org/menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='https://dlang.org/documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/spec/spec.html'>Language Reference</a></li>
    <li><a href='https://dlang.org/phobos/index.html'>Library Reference</a></li>
    <li><a href='https://dlang.org/dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='https://dlang.org/comparison.html'>Feature Overview</a></li>
    <li><a href='https://dlang.org/articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='https://dlang.org/download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='https://dlang.org/community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='https://dlang.org/orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.freenode.net/d'>IRC</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='https://dlang.org/bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='https://dlang.org/foundation.html'>Foundation</a></li>
    <li><a href='https://dlang.org/donate.html'>Donate</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='https://dlang.org/resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='https://dlang.org/acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='https://dlang.org/dstyle.html'>D Style</a></li>
    <li><a href='https://dlang.org/glossary.html'>Glossary</a></li>
    <li><a href='https://dlang.org/sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="https://dlang.org/search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option selected value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/phobos/&amp;bug_severity=enhancement&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5Bdecimal.decimal%5D&amp;version=D2">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/decimal\decimal.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1><span class="d_inlinecode donthyphenate notranslate">decimal.decimal</span></h1>
        <div class="quickindex" id="quickindex"></div>
        IEEE 754-2008 implementation of decimal floating point data types.
Decimal values are represented in memory using a coefficient and a 10-base exponent.
Implementation is based on
<a href="https://en.wikipedia.org/wiki/Binary_Integer_Decimal">binary integer decimal encoding</a>, supported by Intel.
<br><br>
Decimal data types use the same semantics as the built-in floating point data type (NaNs, infinities, etc.),
the main difference being that they use internally a 10 exponent instead of a 2 exponent.
<div class="blankline"></div>

The current implementation supports three decimal data types, as specified by IEEE 754-2008 standard.
The supported types are: <a href="#.decimal32"><em class="tt">decimal32</em></a>&nbsp;, <a href="#.decimal64"><em class="tt">decimal64</em></a>&nbsp; and <a href="#.decimal128"><em class="tt">decimal128</em></a>&nbsp;, but they can be easily extended
to other bit widths if a underlying unsigned integral type is provided.
<div class="blankline"></div>

Decimal data types are best used in financial applications because arithmetic operation results are exact.
<div class="blankline"></div>

<script type="text/javascript">inhibitQuickIndex = 1;</script>
<div class="quickindex"> <table class="book"><caption></caption>  <tr><th scope="col">Category</th> <th scope="col">Members</th> </tr>
    <tr><td class="donthyphenate nobr">Classics</td> <td>        <a href="#.copysign"><em class="tt">copysign</em></a>&nbsp; <a href="#.fabs"><em class="tt">fabs</em></a>&nbsp;
        <a href="#.fmod"><em class="tt">fmod</em></a>&nbsp; <a href="#.fma"><em class="tt">fma</em></a>&nbsp; <a href="#.getNaNPayload"><em class="tt">getNaNPayload</em></a>&nbsp;
        <a href="#.modf"><em class="tt">modf</em></a>&nbsp; <a href="#.NaN"><em class="tt">NaN</em></a>&nbsp;
        <a href="#.nextDown"><em class="tt">nextDown</em></a>&nbsp;  <a href="#.nextUp"><em class="tt">nextUp</em></a>&nbsp; <a href="#.remainder"><em class="tt">remainder</em></a>&nbsp; <a href="#.sgn"><em class="tt">sgn</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Comparison</td> <td>        <a href="#.cmp"><em class="tt">cmp</em></a>&nbsp;
        <a href="#.fmax"><em class="tt">fmax</em></a>&nbsp; <a href="#.fmaxAbs"><em class="tt">fmaxAbs</em></a>&nbsp; <a href="#.fmin"><em class="tt">fmin</em></a>&nbsp; <a href="#.fminAbs"><em class="tt">fminAbs</em></a>&nbsp;
        <a href="#.isEqual"><em class="tt">isEqual</em></a>&nbsp; <a href="#.isGreater"><em class="tt">isGreater</em></a>&nbsp; <a href="#.isGreaterOrEqual"><em class="tt">isGreaterOrEqual</em></a>&nbsp; <a href="#.isGreaterOrUnordered"><em class="tt">isGreaterOrUnordered</em></a>&nbsp;
        <a href="#.isIdentical"><em class="tt">isIdentical</em></a>&nbsp;
        <a href="#.isLess"><em class="tt">isLess</em></a>&nbsp; <a href="#.isLessOrEqual"><em class="tt">isLessOrEqual</em></a>&nbsp; <a href="#.isLessOrUnordered"><em class="tt">isLessOrUnordered</em></a>&nbsp;
        <a href="#.isLessOrGreater"><em class="tt">isLessOrGreater</em></a>&nbsp;
        <a href="#.isNotEqual"><em class="tt">isNotEqual</em></a>&nbsp;
        <a href="#.sameQuantum"><em class="tt">sameQuantum</em></a>&nbsp;
        <a href="#.totalOrder"><em class="tt">totalOrder</em></a>&nbsp; <a href="#.totalOrderAbs"><em class="tt">totalOrderAbs</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Conversion</td> <td>        <a href="#.fromDPD"><em class="tt">fromDPD</em></a>&nbsp; <a href="#.fromMsCurrency"><em class="tt">fromMsCurrency</em></a>&nbsp; <a href="#.fromMsDecimal"><em class="tt">fromMsDecimal</em></a>&nbsp; <a href="#.to"><em class="tt">to</em></a>&nbsp; <a href="#.toDPD"><em class="tt">toDPD</em></a>&nbsp; <a href="#.toExact"><em class="tt">toExact</em></a>&nbsp;
        <a href="#.toMsCurrency"><em class="tt">toMsCurrency</em></a>&nbsp; <a href="#.toMsDecimal"><em class="tt">toMsDecimal</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Data types</td> <td>        <a href="#.Decimal"><em class="tt">Decimal</em></a>&nbsp; <a href="#.decimal32"><em class="tt">decimal32</em></a>&nbsp; <a href="#.decimal64"><em class="tt">decimal64</em></a>&nbsp;  <a href="#.decimal128"><em class="tt">decimal128</em></a>&nbsp;
        <a href="#.DecimalClass"><em class="tt">DecimalClass</em></a>&nbsp; <a href="#.DecimalControl"><em class="tt">DecimalControl</em></a>&nbsp; <a href="#.ExceptionFlags"><em class="tt">ExceptionFlags</em></a>&nbsp;  <a href="#.Precision"><em class="tt">Precision</em></a>&nbsp;
        <a href="#.RoundingMode"><em class="tt">RoundingMode</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Exceptions</td> <td>        <a href="#.DecimalException"><em class="tt">DecimalException</em></a>&nbsp; <a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;
        <a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp; <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;
        <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp; <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Exponentiations &amp; logarithms</td> <td>        <a href="#.cbrt"><em class="tt">cbrt</em></a>&nbsp; <a href="#.compound"><em class="tt">compound</em></a>&nbsp;
        <a href="#.exp"><em class="tt">exp</em></a>&nbsp; <a href="#.exp10"><em class="tt">exp10</em></a>&nbsp; <a href="#.exp10m1"><em class="tt">exp10m1</em></a>&nbsp; <a href="#.exp2"><em class="tt">exp2</em></a>&nbsp; <a href="#.exp2m1"><em class="tt">exp2m1</em></a>&nbsp; <a href="#.expm1"><em class="tt">expm1</em></a>&nbsp; <a href="#.frexp"><em class="tt">frexp</em></a>&nbsp;
        <a href="#.ilogb"><em class="tt">ilogb</em></a>&nbsp; <a href="#.ldexp"><em class="tt">ldexp</em></a>&nbsp; <a href="#.log"><em class="tt">log</em></a>&nbsp; <a href="#.log10"><em class="tt">log10</em></a>&nbsp; <a href="#.log10p1"><em class="tt">log10p1</em></a>&nbsp; <a href="#.log2"><em class="tt">log2</em></a>&nbsp; <a href="#.log2p1"><em class="tt">log2p1</em></a>&nbsp;
        <a href="#.logp1"><em class="tt">logp1</em></a>&nbsp; <a href="#.nextPow10"><em class="tt">nextPow10</em></a>&nbsp; <a href="#.pow"><em class="tt">pow</em></a>&nbsp; <a href="#.root"><em class="tt">root</em></a>&nbsp;
        <a href="#.rsqrt"><em class="tt">rsqrt</em></a>&nbsp; <a href="#.scalbn"><em class="tt">scalbn</em></a>&nbsp; <a href="#.sqrt"><em class="tt">sqrt</em></a>&nbsp;
        <a href="#.truncPow10"><em class="tt">truncPow10</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Introspection</td> <td>        <a href="#.decimalClass"><em class="tt">decimalClass</em></a>&nbsp;
        <a href="#.isCanonical"><em class="tt">isCanonical</em></a>&nbsp; <a href="#.isFinite"><em class="tt">isFinite</em></a>&nbsp; <a href="#.isInfinity"><em class="tt">isInfinity</em></a>&nbsp; <a href="#.isNaN"><em class="tt">isNaN</em></a>&nbsp; <a href="#.isNormal"><em class="tt">isNormal</em></a>&nbsp;
        <a href="#.isPowerOf10"><em class="tt">isPowerOf10</em></a>&nbsp; <a href="#.isSignaling"><em class="tt">isSignaling</em></a>&nbsp; <a href="#.isSubnormal"><em class="tt">isSubnormal</em></a>&nbsp; <a href="#.isZero"><em class="tt">isZero</em></a>&nbsp;
        <a href="#.signbit"><em class="tt">signbit</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Reduction</td> <td>        <a href="#.dot"><em class="tt">dot</em></a>&nbsp; <a href="#.poly"><em class="tt">poly</em></a>&nbsp; <a href="#.scaledProd"><em class="tt">scaledProd</em></a>&nbsp; <a href="#.scaledProdSum"><em class="tt">scaledProdSum</em></a>&nbsp; <a href="#.scaledProdDiff"><em class="tt">scaledProdDiff</em></a>&nbsp;
        <a href="#.sum"><em class="tt">sum</em></a>&nbsp; <a href="#.sumAbs"><em class="tt">sumAbs</em></a>&nbsp; <a href="#.sumSquare"><em class="tt">sumSquare</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Rounding</td> <td>        <a href="#.ceil"><em class="tt">ceil</em></a>&nbsp; <a href="#.floor"><em class="tt">floor</em></a>&nbsp; <a href="#.lrint"><em class="tt">lrint</em></a>&nbsp; <a href="#.lround"><em class="tt">lround</em></a>&nbsp; <a href="#.nearbyint"><em class="tt">nearbyint</em></a>&nbsp; <a href="#.quantize"><em class="tt">quantize</em></a>&nbsp; <a href="#.rint"><em class="tt">rint</em></a>&nbsp;
        <a href="#.rndtonl"><em class="tt">rndtonl</em></a>&nbsp; <a href="#.round"><em class="tt">round</em></a>&nbsp; <a href="#.trunc"><em class="tt">trunc</em></a>&nbsp;
    </td></tr>
    <tr><td class="donthyphenate nobr">Trigonometry</td> <td>        <a href="#.acos"><em class="tt">acos</em></a>&nbsp; <a href="#.acosh"><em class="tt">acosh</em></a>&nbsp; <a href="#.asin"><em class="tt">asin</em></a>&nbsp; <a href="#.asinh"><em class="tt">asinh</em></a>&nbsp; <a href="#.atan"><em class="tt">atan</em></a>&nbsp; <a href="#.atan2"><em class="tt">atan2</em></a>&nbsp; <a href="#.atan2pi"><em class="tt">atan2pi</em></a>&nbsp;
        <a href="#.atanh"><em class="tt">atanh</em></a>&nbsp; <a href="#.atanpi"><em class="tt">atanpi</em></a>&nbsp; <a href="#.cos"><em class="tt">cos</em></a>&nbsp; <a href="#.cosh"><em class="tt">cosh</em></a>&nbsp; <a href="#.cospi"><em class="tt">cospi</em></a>&nbsp;
        <a href="#.hypot"><em class="tt">hypot</em></a>&nbsp; <a href="#.sin"><em class="tt">sin</em></a>&nbsp; <a href="#.sinh"><em class="tt">sinh</em></a>&nbsp; <a href="#.sinpi"><em class="tt">sinpi</em></a>&nbsp; <a href="#.tan"><em class="tt">tan</em></a>&nbsp; <a href="#.tanh"><em class="tt">tanh</em></a>&nbsp;
    </td></tr>
<div class="blankline"></div>

<div class="blankline"></div>

 </table>
</div>
<div class="blankline"></div>


<br><br>
<b>Context</b><br><br>
All arithmetic operations are performed using a <em class="u">thread local context</em>. The context is setting various
environment options:
<ul> <li><b>precision</b> - number of digits used. Each decimal data type has a default precision and all the calculations are
                  performed using this precision. Setting the precision to a custom value will affect
                  any subsequent operation and all the calculations will be performed using the specified
                  number of digits. See <a href="#.Precision"><em class="tt">Precision</em></a>&nbsp; for details;</li>
 <li><b>rounding</b>  - rounding method used to adjust operation results. If a result will have more digits than the current
                  context precision, it will be rounded using the specified method. For available rounding modes,
                  see <a href="#.RoundingMode"><em class="tt">RoundingMode</em></a>&nbsp; for details;</li>
 <li><b>flags</b>     - error flags. Every decimal operation may signal an error. The context will gather these errors for
                  later introspection. See <a href="#.ExceptionFlags"><em class="tt">ExceptionFlags</em></a>&nbsp; for details;</li>
 <li><b>traps</b>     - exception traps. Any error flag which is set may trigger a <a href="#.DecimalException"><em class="tt">DecimalException</em></a>&nbsp; if
                  the corresponding trap is installed. See <a href="#.ExceptionFlags"><em class="tt">ExceptionFlags</em></a>&nbsp; for details;</li>
</ul>

<br><br>
<b>Operators</b><br><br>
All floating point operators are implemented. Binary operators accept as right side argument any decimal, integral or
floating point type.

<br><br>
<b>Initialization</b><br><br>
Creating decimal floating point values can be done in several ways:
<ul> <li>by assigning a binary floating point, integral, char, bool, string or character range value:
<pre class="d_code">decimal32 d = 123;
decimal64 e = 12.34;
decimal128 f = <span class="d_string">"24.9"</span>;
decimal32 g = 'Y';
decimal32 h = <span class="d_keyword">true</span>;
</pre>
</li>
 <li>by using one of the available contructors.
   Suported type are floating point, integrals, chars, bool, strings or character ranges:
<pre class="d_code"><span class="d_keyword">auto</span> d = decimal32(7500);
<span class="d_keyword">auto</span> e = decimal64(52.16);
<span class="d_keyword">auto</span> f - decimal128(<span class="d_string">"199.4E-12"</span>);
<span class="d_keyword">auto</span> g = decimal32('a');
<span class="d_keyword">auto</span> h = decimal32(<span class="d_keyword">false</span>);
</pre>
</li>
 <li>using one of predefined constants:
<pre class="d_code"><span class="d_keyword">auto</span> d = decimal32.nan;
<span class="d_keyword">auto</span> e = decimal64.PI;
<span class="d_keyword">auto</span> f - decimal128.infinity;
</pre>
</li>
</ul>

<br><br>
<b>Error handling</b><br><br>
Errors occuring in arithmetic operations using decimal values can be handled in two ways. By default, the thread local
context will throw exceptions for errors considered severe (<a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;,
<a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp; or <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;).
Any other error is considered silent and the context will only
set corresponding error flags (<a href="#.ExceptionFlags.inexact"><em class="tt">ExceptionFlags.inexact</em></a>&nbsp; or <a href="#.ExceptionFlags.underflow"><em class="tt">ExceptionFlags.underflow</em></a>&nbsp;)<br/>
Most of the operations will throw <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if a signaling NaN is encountered,
if not stated otherwise in the documentation. This is to avoid usage of unitialized variables
(decimal values are always initialized to signaling NaN)
<pre class="d_code"><span class="d_comment">//these will throw:
</span><span class="d_keyword">auto</span> a = decimal32() + 12;    <span class="d_comment">//InvalidOperationException
</span><span class="d_keyword">auto</span> b = decimal32.min / 0;   <span class="d_comment">//DivisionByZeroException
</span><span class="d_keyword">auto</span> c = decimal32.max * 2;   <span class="d_comment">//OverflowException
</span>
<span class="d_comment">//these will not throw:
</span><span class="d_keyword">auto</span> d = decimal32(123456789);                  <span class="d_comment">//inexact
</span><span class="d_keyword">auto</span> e = decimal32.min_normal / decimal32.max;  <span class="d_comment">//underflow
</span></pre>
<div class="blankline"></div>

Default behaviour can be altered using <a href="#.DecimalControl"><em class="tt">DecimalControl</em></a>&nbsp; by setting or clearing corresponding traps:
<pre class="d_code">DecimalControl.disableExceptions(ExceptionFlags.overflow)
<span class="d_comment">//from now on OverflowException will not be thrown;
</span>
DecimalControl.enableExceptions(ExceptionFlags.inexact)
<span class="d_comment">//from now on InexactException will be thrown
</span></pre>
<div class="blankline"></div>

<ul>  <li>Catching exceptions</li>
<pre class="d_code"><span class="d_keyword">try</span>
{
   <span class="d_keyword">auto</span> a = decimal32.min / 0;
}
<span class="d_keyword">catch</span> (DivisionByZeroException)
{
   <span class="d_comment">//error occured
</span>}
</pre>
  <li>Checking for errors</li>
<pre class="d_code">DecimalControl.resetFlags();
<span class="d_keyword">auto</span> a = decimal32.min / 0;
<span class="d_keyword">if</span> (DecimalControl.divisionByZero)
{
   <span class="d_comment">//error occured
</span>}
</pre>
</ul>

<br><br>
<b>Properties</b><br><br>
The following properties are defined for each decimal type:
<div class="blankline"></div>

<table class="book"><caption></caption> <tr><th scope="col">Constant</th> <th scope="col">Name</th> <th scope="col">decimal32</th> <th scope="col">decimal64</th> <th scope="col">decimal128</th></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">init</span></td> <td>initial value</td> <td>signaling NaN</td> <td>signaling NaN</td> <td>signaling NaN</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">nan</span></td> <td>Not a Number</td> <td>NaN</td> <td>NaN</td> <td>NaN</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">infinity</span></td> <td>positive infinity</td> <td>+∞</td> <td>+∞</td> <td>+∞</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">dig</span></td> <td>precision</td> <td>7</td> <td>16</td> <td>34</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">epsilon</span></td> <td>smallest increment to the value 1</td> <td>10<sup>-6</sup></td> <td>10<sup>-15</sup></td> <td>10<sup>-33</sup></td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">mant_dig</span></td> <td>number of bits in mantissa</td> <td>24</td> <td>54</td> <td>114</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">max_10_exp</span></td> <td>maximum int value such that 10<sup>max_10_exp</sup> is representable</td> <td>96</td> <td>384</td> <td>6144</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">min_10_exp</span></td> <td>minimum int value such that 10<sup>min_10_exp</sup> is representable and normalized</td> <td>-95</td> <td>-383</td> <td>-6143</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">max_2_exp</span></td> <td>maximum int value such that 2<sup>max_2_exp</sup> is representable</td> <td>318</td> <td>1275</td> <td>20409</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">min_2_exp</span></td> <td>minimum int value such that 2<sup>min_2_exp</sup> is representable and normalized</td> <td>-315</td> <td>-1272</td> <td>-20406</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">max</span></td> <td>largest representable value that's not infinity</td> <td>9.(9) * 10<sup>96</sup></td> <td>9.(9) * 10<sup>384</sup></td> <td>9.(9) * 10<sup>6144</sup></td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">min_normal</span></td> <td>smallest normalized value that's not 0</td> <td>10<sup>-95</sup></td> <td>10<sup>-383</sup></td> <td>10<sup>-6143</sup></td></tr>
</table>
<div class="blankline"></div>


<br><br>
<b>Useful constants</b><br><br>
There are common constants defined for each type. Values below have 34 digits of precision corresponding
to decimal128 data type; for decimal64 and decimal32, they are rounded away from 0 according to their respecive precision.
<pre class="d_code"><span class="d_keyword">auto</span> a = decimal32.PI;
<span class="d_keyword">auto</span> b = decimal64.LN2;
<span class="d_keyword">auto</span> c = decimal128.E;
</pre>
<div class="blankline"></div>

<table class="book"><caption></caption> <tr><th scope="col">Constant</th> <th scope="col">Formula</th> <th scope="col">Value</th></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">E</span></td> <td>e</td> <td>2.7182818284590452353602874713526625</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">PI</span></td> <td>π</td> <td>3.1415926535897932384626433832795029</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">PI_2</span></td> <td>π/2</td> <td>1.5707963267948966192313216916397514</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">PI_4</span></td> <td>π/4</td> <td>0.7853981633974483096156608458198757</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">M_1_PI</span></td> <td>1/π</td> <td>0.3183098861837906715377675267450287</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">M_2_PI</span></td> <td>2/π</td> <td>0.6366197723675813430755350534900574</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">M_2_SQRTPI</span></td> <td>2/√π</td> <td>1.1283791670955125738961589031215452</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">SQRT2</span></td> <td>√2</td> <td>1.4142135623730950488016887242096981</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">SQRT1_2</span></td> <td>√½</td> <td>0.7071067811865475244008443621048490</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">LN10</span></td> <td>log<sub>e</sub>10</td> <td>2.3025850929940456840179914546843642</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">LOG2T</span></td> <td>log<sub>2</sub>10</td> <td>3.3219280948873623478703194294893902</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">LOG2E</span></td> <td>log<sub>2</sub>e</td> <td>1.4426950408889634073599246810018921</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">LOG2</span></td> <td>log<sub>10</sub>2</td> <td>0.3010299956639811952137388947244930</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">LOG10E</span></td> <td>log<sub>10</sub>e</td> <td>0.4342944819032518276511289189166051</td></tr>
 <tr><td><span class="d_inlinecode donthyphenate notranslate">LN2</span></td> <td>log<sub>e</sub>2</td> <td>0.6931471805599453094172321214581766</td></tr>
</table>
<div class="blankline"></div>

<div class="blankline"></div>


<br><br>
<b>Special remarks</b><br><br>
<ul> <li>Avoid mixing binary floating point values with <span class="def-anchor" id="decimal"></span><code class="ddoc_psymbol">decimal</code> values, binary foating point values cannot exactly represent 10-based exponents;</li>
 <li>There are many representations for the same number (IEEE calls them cohorts). Comparing bit by bit two decimal values is error prone;</li>
 <li>The comparison operator will return float.nan for an unordered result; There is no operator overloading for unordered comparisons;</li>
 <li>Hexadecimal notation allows to define uncanonical coefficients (&gt; 10 <sup>precision</sup> - 1). According to IEEE standard, these values are considered equal to 0;</li>
</ul>

<br><br>
<b>Performance tips</b><br><br>
<ul> <li>When performing decimal calculations, avoid binary floating point; conversion for base-2 from/to base-10 is costly;</li>
 <li>Avoid custom precisions; rounding is expensive since most of the time will involve a division operation;</li>
 <li>Use decimal128 only if you truly need 34 digits of precision. decimal64 and decimal32 arithmetic is much faster;</li>
 <li>Avoid traps and check yourself for flags; throwing and catching exceptions is expensive;</li>
 <li>Contrary to usual approach, multiplication/division by 10 for decimal values is faster than multiplication/division by 2;</li>
</ul>
<div class="blankline"></div>


<br><br>
<b>License:</b><br>
        <a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<br><br><b>Authors:</b><br>
        Răzvan Ștefănescu
<br><br><b>Source</b><br><br>
<a href="https://github.com/rumbu13/decimal/blob/master/src/package.d">decimal.d</a><br><br>

<dl><dt><em class="big"><span class="def-anchor" id=".Decimal"></span><div class="quickindex" id="quickindex.Decimal"></div>struct <span class="def-anchor" id="Decimal"></span><code class="ddoc_psymbol">Decimal</code>(int bits) if (bits == 32 || bits == 64 || bits == 128);
</em></dt>
<dd>Decimal floating-point computer numbering format that occupies 4, 8 or 16 bytes in computer memory.<br><br>

<dl><dt><em class="big"><span class="def-anchor" id=".Decimal.radix"></span><div class="quickindex" id="quickindex.Decimal.radix"></div>enum auto <span class="def-anchor" id="radix"></span><code class="ddoc_psymbol">radix</code>;
</em></dt>
<dd>always 10 for decimal data types<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.this"></span><div class="quickindex" id="quickindex.Decimal.this"></div>this(T)(auto ref const T <code class="ddoc_param">value</code>);
</em></dt>
<dd>Constructs a Decimal data type using the specified value
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>T <code class="ddoc_param">value</code></td>
<td>any integral, char, bool, floating point, decimal, string or character range value</td></tr>
</caption></table><br><b>Exceptions</b><br><br>
<table class="book"><caption></caption>            <tr><th scope="col">Data type</th> <th scope="col">Invalid</th> <th scope="col">Overflow</th> <th scope="col">Underflow</th> <th scope="col">Inexact</th></tr>
            <tr><td>integral</td>  <td>       </td> <td>        </td> <td>         </td> <td>✓     </td></tr>
            <tr><td>char    </td>  <td>       </td> <td>        </td> <td>         </td> <td>✓     </td></tr>
            <tr><td>float   </td>  <td>       </td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
            <tr><td>bool    </td>  <td>       </td> <td>        </td> <td>         </td> <td>       </td></tr>
            <tr><td>decimal </td>  <td>       </td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
            <tr><td>string  </td>  <td>✓     </td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
            <tr><td>range   </td>  <td>✓     </td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
        </table>
<br><br>
<b>Using integral values</b><br><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = decimal32(112);       <span class="d_comment">//represented as 112 x 10^^0;
</span><span class="d_keyword">auto</span> b = decimal32(123456789); <span class="d_comment">//inexact, represented as 1234568 * x 10^^2
</span></pre>
<br><br>
<b>Using floating point values</b><br><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = decimal32(1.23);
<span class="d_comment">//inexact, represented as 123 x 10^^-2,
</span><span class="d_comment">//because floating point data cannot exactly represent 1.23
</span><span class="d_comment">//in fact 1.23 as float is 1.230000019073486328125
</span><span class="d_keyword">auto</span> b = decimal64(<span class="d_keyword">float</span>.nan);
</pre>
<br><br>
<b>Using other decimal values</b><br><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = decimal32(decimal64(10));
<span class="d_keyword">auto</span> b = decimal64(a);
<span class="d_keyword">auto</span> c = decimal64(decimal128.nan);
</pre>
<br><br>
<b>Using strings or ranges</b><br><br>
        A decimal <code class="ddoc_param">value</code> can be defined based on decimal, scientific or hexadecimal representation:
        <ul>            <li>values are rounded away from zero in case of precision overflow;</li>
<pre class="d_code"><span class="d_keyword">auto</span> d = decimal32(<span class="d_string">"2.3456789"</span>)
<span class="d_comment">//internal representation will be 2.345679
</span><span class="d_comment">//because decimal32 has a 7-digit precision
</span></pre>
            <li>the exponent in hexadecimal notation is 10-based;</li>
<pre class="d_code"><span class="d_keyword">auto</span> d1 = decimal64(<span class="d_string">"0x00003p+21"</span>);
<span class="d_keyword">auto</span> d2 = decimal64(<span class="d_string">"3e+21"</span>);
<span class="d_keyword">assert</span> (d1 == d2);
</pre>
            <li>the hexadecimal notation doesn't have any decimal point,
                because there is no leading 1 as for binary floating point values;</li>
            <li>there is no octal notation, any leading zero before the decimal point is ignored;</li>
            <li>digits can be grouped using underscores;</li>
            <li>case insensitive special values are accepted: <b>nan, qnan, snan, inf, infinity</b>;</li>
            <li>there is no digit count limit for decimal representation, very large values are rounded and adjusted by
                increasing the 10-exponent;</li>
<pre class="d_code"><span class="d_keyword">auto</span> d1 = decimal32(<span class="d_string">"123_456_789_123_456_789_123_456_789_123"</span>); <span class="d_comment">//30 digits
</span><span class="d_comment">//internal representation will be 1.234568 x 10^^30
</span></pre>
            <li>NaN payloads can be defined betwen optional brackets ([], (), {}, &lt;&gt;).
            The payload is unsigned and is accepted in decimal or hexadecimal format;</li>
        </ul>
<pre class="d_code"><span class="d_keyword">auto</span> d = decimal32(<span class="d_string">"10"</span>);              <span class="d_comment">//integral
</span><span class="d_keyword">auto</span> e = decimal64(<span class="d_string">"125.43"</span>)           <span class="d_comment">//floating point
</span><span class="d_keyword">auto</span> f = decimal128(<span class="d_string">"123.456E-32"</span>);    <span class="d_comment">//scientific
</span><span class="d_keyword">auto</span> g = decimal32(<span class="d_string">"0xABCDEp+21"</span>);     <span class="d_comment">//hexadecimal 0xABCD * 10^^21
</span><span class="d_keyword">auto</span> h = decimal64(<span class="d_string">"NaN1234"</span>);         <span class="d_comment">//NaN with 1234 payload
</span><span class="d_keyword">auto</span> i = decimal128(<span class="d_string">"sNaN&lt;0xABCD&gt;"</span>)    <span class="d_comment">//signaling NaN with a 0xABCD payload
</span><span class="d_keyword">auto</span> j = decimal32(<span class="d_string">"inf"</span>);             <span class="d_comment">//infinity
</span></pre>
<br><br>
<b>Using char or bool values</b><br><br>
        These constructors are provided only from convenience, and to
        offer support for conversion function <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_conv.html#to">to</a></span>.
        Char values are cast to unsigned int.
        Bool values are converted to 0.0 (<code class="ddoc_keyword">false</code>) or 1.0 (<code class="ddoc_keyword">true</code>)
<pre class="d_code"><span class="d_keyword">auto</span> a = decimal32(<span class="d_keyword">true</span>); <span class="d_comment">//1.0
</span><span class="d_keyword">auto</span> b = decimal32('a');  <span class="d_comment">//'a' ascii code (97)
</span>
<span class="d_keyword">auto</span> c = to!decimal32(<span class="d_keyword">false</span>); <span class="d_comment">//phobos to!(bool, decimal32)
</span><span class="d_keyword">auto</span> d = to!decimal128('Z');  <span class="d_comment">//phobos to!(char, decimal128)
</span></pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.opAssign"></span><div class="quickindex" id="quickindex.Decimal.opAssign"></div>ref auto <span class="def-anchor" id="opAssign"></span><code class="ddoc_psymbol">opAssign</code>(T)(auto ref const T <code class="ddoc_param">value</code>);
</em></dt>
<dd>Implementation of assignnment operator. It supports the same semantics as the constructor.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.opCast"></span><div class="quickindex" id="quickindex.Decimal.opCast"></div>const T <span class="def-anchor" id="opCast"></span><code class="ddoc_psymbol">opCast</code>(T)();
</em></dt>
<dd>Implementation of cast operator. Supported casts: integral, floating point, decimal, char, bool
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>            <tr><th scope="col">Data type</th> <th scope="col">Invalid</th> <th scope="col">Overflow</th> <th scope="col">Underflow</th> <th scope="col">Inexact</th></tr>
            <tr><td>integral</td>  <td>     ✓</td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
            <tr><td>char    </td>  <td>     ✓</td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
            <tr><td>float   </td>  <td>       </td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
            <tr><td>bool    </td>  <td>       </td> <td>        </td> <td>         </td> <td>       </td></tr>
            <tr><td>decimal </td>  <td>       </td> <td>✓      </td> <td>✓       </td> <td>✓     </td></tr>
        </table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.opUnary"></span><div class="quickindex" id="quickindex.Decimal.opUnary"></div>const pure nothrow @nogc @safe auto <span class="def-anchor" id="opUnary"></span><code class="ddoc_psymbol">opUnary</code>(string op : "+")();
<br>const pure nothrow @nogc @safe auto <span class="def-anchor" id="opUnary"></span><code class="ddoc_psymbol">opUnary</code>(string op : "-")();
</em></dt>
<dd>Implementation of +/- unary operators. These operations are silent, no exceptions are thrown<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.opUnary.2"></span><div class="quickindex" id="quickindex.Decimal.opUnary.2"></div>ref @safe auto <span class="def-anchor" id="opUnary"></span><code class="ddoc_psymbol">opUnary</code>(string op : "++")();
<br>ref @safe auto <span class="def-anchor" id="opUnary"></span><code class="ddoc_psymbol">opUnary</code>(string op : "--")();
</em></dt>
<dd>Implementation of ++/-- unary operators.
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>            <tr><th scope="col">Value</th> <th scope="col">++/-- </th> <th scope="col">Invalid</th> <th scope="col">Overflow</th> <th scope="col">Inexact</th></tr>
            <tr><td>NaN  </td> <td>NaN   </td> <td>✓     </td> <td>        </td> <td>       </td></tr>
            <tr><td>±∞   </td> <td>±∞    </td> <td>       </td> <td>        </td> <td>       </td></tr>
            <tr><td>any  </td> <td>any   </td> <td>       </td> <td>✓      </td> <td>✓     </td></tr>
        </table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.opEquals"></span><div class="quickindex" id="quickindex.Decimal.opEquals"></div>const bool <span class="def-anchor" id="opEquals"></span><code class="ddoc_psymbol">opEquals</code>(T)(auto ref const T <code class="ddoc_param">value</code>);
</em></dt>
<dd>Implementation of == operator. This operation is silent, no exceptions are thrown.
    Supported types : decimal, floating point, integral, char<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.opCmp"></span><div class="quickindex" id="quickindex.Decimal.opCmp"></div>const float <span class="def-anchor" id="opCmp"></span><code class="ddoc_psymbol">opCmp</code>(T)(auto ref const T <code class="ddoc_param">value</code>);
</em></dt>
<dd>Implementation of comparison operator.
    Supported types : decimal, floating point, integral, char
    <table class="book"><caption></caption>            <tr><th scope="col">this</th> <th scope="col">Value</th> <th scope="col">Result</th>    <th scope="col">Invalid</th></tr>
            <tr><td>NaN </td> <td>any  </td> <td>NaN   </td>    <td>✓     </td></tr>
            <tr><td>any </td> <td>NaN  </td> <td>NaN   </td>    <td>✓     </td></tr>
            <tr><td>any </td> <td>any  </td> <td>±1.0, 0.0</td> <td>       </td></tr>
        </table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.opBinary"></span><div class="quickindex" id="quickindex.Decimal.opBinary"></div>const auto <span class="def-anchor" id="opBinary"></span><code class="ddoc_psymbol">opBinary</code>(string op, T)(auto ref const T <code class="ddoc_param">value</code>) if (op == "+" || op == "-" || op == "*" || op == "/" || op == "%" || op == "^^");
<br><span class="def-anchor" id=".Decimal.opBinaryRight"></span><div class="quickindex" id="quickindex.Decimal.opBinaryRight"></div>const auto <span class="def-anchor" id="opBinaryRight"></span><code class="ddoc_psymbol">opBinaryRight</code>(string op, T)(auto ref const T <code class="ddoc_param">value</code>) if (op == "+" || op == "-" || op == "*" || op == "/" || op == "%" || op == "^^");
<br><span class="def-anchor" id=".Decimal.opOpAssign"></span><div class="quickindex" id="quickindex.Decimal.opOpAssign"></div>auto <span class="def-anchor" id="opOpAssign"></span><code class="ddoc_psymbol">opOpAssign</code>(string op, T)(auto ref const T <code class="ddoc_param">value</code>) if (op == "+" || op == "-" || op == "*" || op == "/" || op == "%" || op == "^^");
</em></dt>
<dd>Implementation of binary and assignment operators (+, -, *, /, %, ^^).
<br><br>
<b>Returns:</b><br>
        the widest decimal <code class="ddoc_param">value</code> as result of the operation
<br><br><b>Supported types</b><br><br>
decimal, floating point, integral, char
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>        <tr><th scope="col">Left</th> <th scope="col">Op</th> <th scope="col">Right</th> <th scope="col">Result</th> <th scope="col">Invalid</th> <th scope="col">Div0</th> <th scope="col">Overflow</th> <th scope="col">Underflow</th> <th scope="col">Inexact</th></tr>
        <tr><td>NaN</td> <td>any</td> <td>any</td> <td>NaN</td>      <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>any</td> <td>NaN</td> <td>NaN</td>      <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>+∞</td> <td>+</td> <td>-∞</td> <td>NaN</td>          <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>+∞</td> <td>+</td> <td>any</td> <td>+∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>+</td> <td>+∞</td> <td>+∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>-∞</td> <td>+</td> <td>+∞</td> <td>NaN</td>          <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>-∞</td> <td>+</td> <td>any</td> <td>-∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>+</td> <td>-∞</td> <td>-∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>+</td> <td>any</td> <td>any</td>        <td>       </td> <td>    </td> <td>✓      </td> <td>✓      </td>  <td>✓     </td></tr>
        <tr><td>+∞</td> <td>-</td> <td>+∞</td> <td>NaN</td>          <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>+∞</td> <td>-</td> <td>any</td> <td>+∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>-</td> <td>+∞</td> <td>-∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>-∞</td> <td>-</td> <td>-∞</td> <td>NaN</td>          <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>-∞</td> <td>-</td> <td>any</td> <td>-∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>-</td> <td>-∞</td> <td>-∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>-</td> <td>any</td> <td>any</td>        <td>       </td> <td>    </td> <td>✓      </td> <td>✓      </td>  <td>✓     </td></tr>
        <tr><td>±∞</td> <td>*</td> <td>0.0</td> <td>NaN</td>         <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>±∞</td> <td>*</td> <td>any</td> <td>±∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>*</td> <td>any</td> <td>any</td>        <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>±∞</td> <td>/</td> <td>±∞</td> <td>NaN</td>          <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>0.0</td> <td>/</td> <td>0.0</td> <td>NaN</td>        <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>±∞</td> <td>/</td> <td>any</td> <td>±∞</td>          <td>       </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>/</td> <td>0.0</td> <td>±∞</td>         <td>       </td> <td>✓  </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>/</td> <td>any</td> <td>any</td>        <td>       </td> <td>    </td> <td>✓      </td> <td>✓      </td>  <td>✓     </td></tr>
        <tr><td>±∞</td> <td>%</td> <td>any</td> <td>NaN</td>         <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>%</td> <td>±∞</td> <td>NaN</td>         <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>%</td> <td>0.0</td> <td>NaN</td>        <td>✓     </td> <td>    </td> <td>        </td> <td>        </td>  <td>       </td></tr>
        <tr><td>any</td> <td>%</td> <td>any</td> <td>any</td>        <td>       </td> <td>    </td> <td>✓      </td> <td>✓      </td>  <td>✓     </td></tr>
    </table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.toString"></span><div class="quickindex" id="quickindex.Decimal.toString"></div>const void <span class="def-anchor" id="toString"></span><code class="ddoc_psymbol">toString</code>(C)(scope void delegate(const(C)[]) <code class="ddoc_param">sink</code>, FormatSpec!C <code class="ddoc_param">fmt</code>) if (isSomeChar!C);
<br>const void <span class="def-anchor" id="toString"></span><code class="ddoc_psymbol">toString</code>(C)(scope void delegate(const(C)[]) <code class="ddoc_param">sink</code>) if (isSomeChar!C);
</em></dt>
<dd>Converts current value to string, passing it to the given <code class="ddoc_param">sink</code> using
    the specified format.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>void delegate(const(C)[]) <code class="ddoc_param">sink</code></td>
<td>a delegate used to <code class="ddoc_param">sink</code> character arrays;</td></tr>
<tr><td>FormatSpec!C <code class="ddoc_param">fmt</code></td>
<td>a format specification;</td></tr>
</caption></table><br><b>Notes</b><br><br>
This function is not intended to be used directly, it is used by the format, output or conversion
      family of functions from Phobos. All standard format options are supported, except digit grouping.
<br><br>
<b>Supported formats</b><br><br>
<ul>        <li><b>f, F</b> - floating point notation</li>
        <li><b>e, E</b> - scientific notation</li>
        <li><b>a, A</b> - hexadecimal floating point notation</li>
        <li><b>g, G</b> - shortest representation between floating point and scientific notation</li>
        <li><b>s, S</b> - same as <b>g, G</b></li>
      </ul>
<br><br>
<b>Throws:</b><br>
        <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_format.html#FormatException">FormatException</a></span> if the format specifier is not supported
<br><br><b>See Also:</b><br>
        <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_format.html#FormatSpec">FormatSpec</a></span>
       <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_format.html#format">format</a></span>
       <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_conv.html#to">to</a></span>
       <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_stdio.html#writef">writef</a></span>
       <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_stdio.html#writefln">writefln</a></span><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.toString.2"></span><div class="quickindex" id="quickindex.Decimal.toString.2"></div>const string <span class="def-anchor" id="toString"></span><code class="ddoc_psymbol">toString</code>();
</em></dt>
<dd>Converts current value to string in floating point or scientific notation,
which one is shorter.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.toString.3"></span><div class="quickindex" id="quickindex.Decimal.toString.3"></div>const string <span class="def-anchor" id="toString"></span><code class="ddoc_psymbol">toString</code>(C)(FormatSpec!C <code class="ddoc_param">fmt</code>);
<br>const string <span class="def-anchor" id="toString"></span><code class="ddoc_psymbol">toString</code>(C)(const(C)[] <code class="ddoc_param">fmt</code>);
</em></dt>
<dd>Converts current value to string according to the
format specification<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".Decimal.toHash"></span><div class="quickindex" id="quickindex.Decimal.toHash"></div>pure nothrow @nogc @safe size_t <span class="def-anchor" id="toHash"></span><code class="ddoc_psymbol">toHash</code>();
</em></dt>
<dd>Returns a unique hash of the decimal value suitable for use in a hash table.
<br><br>
<b>Notes</b><br><br>
This function is not intended for direct use, it's provided as support for associative arrays.<br><br>

</dd>
</dl>
</dd>
<dt><em class="big"><span class="def-anchor" id=".decimal32"></span><div class="quickindex" id="quickindex.decimal32"></div>alias <span class="def-anchor" id="decimal32"></span><code class="ddoc_psymbol">decimal32</code> = Decimal!32.Decimal;
<br><span class="def-anchor" id=".decimal64"></span><div class="quickindex" id="quickindex.decimal64"></div>alias <span class="def-anchor" id="decimal64"></span><code class="ddoc_psymbol">decimal64</code> = Decimal!64.Decimal;
<br><span class="def-anchor" id=".decimal128"></span><div class="quickindex" id="quickindex.decimal128"></div>alias <span class="def-anchor" id="decimal128"></span><code class="ddoc_psymbol">decimal128</code> = Decimal!128.Decimal;
</em></dt>
<dd>Shorthand notations for <a href="#.Decimal"><em class="tt">Decimal</em></a>&nbsp; types<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".isDecimal"></span><div class="quickindex" id="quickindex.isDecimal"></div>template <span class="def-anchor" id="isDecimal"></span><code class="ddoc_psymbol">isDecimal</code>(D...)</em></dt>
<dd>Returns <code class="ddoc_keyword">true</code> if all specified types are decimal types.<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isDecimal</span>!decimal32);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isDecimal</span>!(decimal32, decimal64));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isDecimal</span>!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isDecimal</span>!(decimal128, <span class="d_keyword">byte</span>));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".CommonDecimal"></span><div class="quickindex" id="quickindex.CommonDecimal"></div>template <span class="def-anchor" id="CommonDecimal"></span><code class="ddoc_psymbol">CommonDecimal</code>(T...) if (isDecimal!T)</em></dt>
<dd>Returns the most wide decimal type among the specified types<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">CommonDecimal</span>!(decimal32, decimal64) == decimal64));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">CommonDecimal</span>!(decimal32, decimal128) == decimal128));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">CommonDecimal</span>!(decimal64, decimal128) == decimal128));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalException"></span><div class="quickindex" id="quickindex.DecimalException"></div>abstract class <span class="def-anchor" id="DecimalException"></span><code class="ddoc_psymbol">DecimalException</code>: <span class="ddoc_psuper_symbol">object.Exception</span>;
</em></dt>
<dd>Root object for all decimal exceptions<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".InvalidOperationException"></span><div class="quickindex" id="quickindex.InvalidOperationException"></div>class <span class="def-anchor" id="InvalidOperationException"></span><code class="ddoc_psymbol">InvalidOperationException</code>: <span class="ddoc_psuper_symbol">decimal.decimal.DecimalException</span>;
</em></dt>
<dd>Thrown if any operand of a decimal operation is not a number or si not finite<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DivisionByZeroException"></span><div class="quickindex" id="quickindex.DivisionByZeroException"></div>class <span class="def-anchor" id="DivisionByZeroException"></span><code class="ddoc_psymbol">DivisionByZeroException</code>: <span class="ddoc_psuper_symbol">decimal.decimal.DecimalException</span>;
</em></dt>
<dd>Thrown if the denominator of a decimal division operation is zero.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".OverflowException"></span><div class="quickindex" id="quickindex.OverflowException"></div>class <span class="def-anchor" id="OverflowException"></span><code class="ddoc_psymbol">OverflowException</code>: <span class="ddoc_psuper_symbol">decimal.decimal.DecimalException</span>;
</em></dt>
<dd>Thrown if the result of a decimal operation exceeds the largest finite number of the destination format.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".UnderflowException"></span><div class="quickindex" id="quickindex.UnderflowException"></div>class <span class="def-anchor" id="UnderflowException"></span><code class="ddoc_psymbol">UnderflowException</code>: <span class="ddoc_psuper_symbol">decimal.decimal.DecimalException</span>;
</em></dt>
<dd>Thrown if the result of a decimal operation is smaller the smallest finite number of the destination format.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".InexactException"></span><div class="quickindex" id="quickindex.InexactException"></div>class <span class="def-anchor" id="InexactException"></span><code class="ddoc_psymbol">InexactException</code>: <span class="ddoc_psuper_symbol">decimal.decimal.DecimalException</span>;
</em></dt>
<dd>Thrown if the result of a decimal operation was rounded to fit in the destination format.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags"></span><div class="quickindex" id="quickindex.ExceptionFlags"></div>enum <span class="def-anchor" id="ExceptionFlags"></span><code class="ddoc_psymbol">ExceptionFlags</code>: uint;
</em></dt>
<dd>These flags indicate that an error has occurred. They indicate that a 0, NaN or an infinity value has been generated,
that a result is inexact, or that a signalling NaN has been encountered.
If the corresponding traps are set using <a href="#.DecimalControl"><em class="tt">DecimalControl</em></a>&nbsp;,
an exception will be thrown after setting these error flags.
<br><br>
By default the context will have all error flags lowered and exceptions are thrown only for severe errors.<br><br>

<dl><dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.none"></span><div class="quickindex" id="quickindex.ExceptionFlags.none"></div><span class="def-anchor" id="none"></span><code class="ddoc_psymbol">none</code></em></dt>
<dd>no error<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.invalidOperation"></span><div class="quickindex" id="quickindex.ExceptionFlags.invalidOperation"></div><span class="def-anchor" id="invalidOperation"></span><code class="ddoc_psymbol">invalidOperation</code></em></dt>
<dd><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; is thrown if trap is set<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.divisionByZero"></span><div class="quickindex" id="quickindex.ExceptionFlags.divisionByZero"></div><span class="def-anchor" id="divisionByZero"></span><code class="ddoc_psymbol">divisionByZero</code></em></dt>
<dd><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp; is thrown if trap is set<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.overflow"></span><div class="quickindex" id="quickindex.ExceptionFlags.overflow"></div><span class="def-anchor" id="overflow"></span><code class="ddoc_psymbol">overflow</code></em></dt>
<dd><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp; is thrown if trap is set<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.underflow"></span><div class="quickindex" id="quickindex.ExceptionFlags.underflow"></div><span class="def-anchor" id="underflow"></span><code class="ddoc_psymbol">underflow</code></em></dt>
<dd><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp; is thrown if trap is set<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.inexact"></span><div class="quickindex" id="quickindex.ExceptionFlags.inexact"></div><span class="def-anchor" id="inexact"></span><code class="ddoc_psymbol">inexact</code></em></dt>
<dd><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp; is thrown if trap is set<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.severe"></span><div class="quickindex" id="quickindex.ExceptionFlags.severe"></div><span class="def-anchor" id="severe"></span><code class="ddoc_psymbol">severe</code></em></dt>
<dd>group of errors considered <span class="def-anchor" id="severe"></span><code class="ddoc_psymbol">severe</code>: invalidOperation, divisionByZero, overflow<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".ExceptionFlags.all"></span><div class="quickindex" id="quickindex.ExceptionFlags.all"></div><span class="def-anchor" id="all"></span><code class="ddoc_psymbol">all</code></em></dt>
<dd><span class="def-anchor" id="all"></span><code class="ddoc_psymbol">all</code> errors<br><br>

</dd>
</dl>
</dd>
<dt><em class="big"><span class="def-anchor" id=".RoundingMode"></span><div class="quickindex" id="quickindex.RoundingMode"></div>enum <span class="def-anchor" id="RoundingMode"></span><code class="ddoc_psymbol">RoundingMode</code>: int;
</em></dt>
<dd>Rounding modes. To better understand how rounding is performed, consult the table below.
<br><br>
<table class="book"><caption></caption>  <tr><th scope="col">Value</th> <th scope="col">tiesToEven</th> <th scope="col">tiesToAway</th> <th scope="col">towardPositive</th> <th scope="col">towardNegative</th> <th scope="col">towardZero</th></tr>
  <tr><td>+1.3</td>  <td>+1</td>         <td>+1</td>         <td>+2</td>             <td>+1</td>             <td>+1</td></tr>
  <tr><td>+1.5</td>  <td>+2</td>         <td>+2</td>         <td>+2</td>             <td>+1</td>             <td>+1</td></tr>
  <tr><td>+1.8</td>  <td>+2</td>         <td>+2</td>         <td>+2</td>             <td>+1</td>             <td>+1</td></tr>
  <tr><td>-1.3</td>  <td>-1</td>         <td>-1</td>         <td>-1</td>             <td>-2</td>             <td>-1</td></tr>
  <tr><td>-1.5</td>  <td>-2</td>         <td>-2</td>         <td>-1</td>             <td>-2</td>             <td>-1</td></tr>
  <tr><td>-1.8</td>  <td>-2</td>         <td>-2</td>         <td>-1</td>             <td>-2</td>             <td>-1</td></tr>
  <tr><td>+2.3</td>  <td>+2</td>         <td>+2</td>         <td>+3</td>             <td>+2</td>             <td>+2</td></tr>
  <tr><td>+2.5</td>  <td>+2</td>         <td>+3</td>         <td>+3</td>             <td>+2</td>             <td>+2</td></tr>
  <tr><td>+2.8</td>  <td>+3</td>         <td>+3</td>         <td>+3</td>             <td>+2</td>             <td>+2</td></tr>
  <tr><td>-2.3</td>  <td>-2</td>         <td>-2</td>         <td>-2</td>             <td>-3</td>             <td>-2</td></tr>
  <tr><td>-2.5</td>  <td>-2</td>         <td>-3</td>         <td>-2</td>             <td>-3</td>             <td>-2</td></tr>
  <tr><td>-2.8</td>  <td>-3</td>         <td>-3</td>         <td>-2</td>             <td>-3</td>             <td>-2</td></tr>
 </table><br><br>

<dl><dt><em class="big"><span class="def-anchor" id=".RoundingMode.tiesToEven"></span><div class="quickindex" id="quickindex.RoundingMode.tiesToEven"></div><span class="def-anchor" id="tiesToEven"></span><code class="ddoc_psymbol">tiesToEven</code></em></dt>
<dd>rounded away from zero; halfs are rounded to the nearest even number<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".RoundingMode.tiesToAway"></span><div class="quickindex" id="quickindex.RoundingMode.tiesToAway"></div><span class="def-anchor" id="tiesToAway"></span><code class="ddoc_psymbol">tiesToAway</code></em></dt>
<dd>rounded away from zero<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".RoundingMode.towardPositive"></span><div class="quickindex" id="quickindex.RoundingMode.towardPositive"></div><span class="def-anchor" id="towardPositive"></span><code class="ddoc_psymbol">towardPositive</code></em></dt>
<dd>truncated toward positive infinity<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".RoundingMode.towardNegative"></span><div class="quickindex" id="quickindex.RoundingMode.towardNegative"></div><span class="def-anchor" id="towardNegative"></span><code class="ddoc_psymbol">towardNegative</code></em></dt>
<dd>truncated toward negative infinity<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".RoundingMode.towardZero"></span><div class="quickindex" id="quickindex.RoundingMode.towardZero"></div><span class="def-anchor" id="towardZero"></span><code class="ddoc_psymbol">towardZero</code></em></dt>
<dd>truncated toward zero<br><br>

</dd>
</dl>
</dd>
<dt><em class="big"><span class="def-anchor" id=".Precision"></span><div class="quickindex" id="quickindex.Precision"></div>alias <span class="def-anchor" id="Precision"></span><code class="ddoc_psymbol">Precision</code> = uint;
</em></dt>
<dd>Precision used to round decimal operation results. Every result will be adjusted
to fit the specified precision. Use <a href="#.DecimalControl"><em class="tt">DecimalControl</em></a>&nbsp; to query or set the
context precision<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".precisionDefault"></span><div class="quickindex" id="quickindex.precisionDefault"></div><span class="def-anchor" id="precisionDefault"></span><code class="ddoc_psymbol">precisionDefault</code></em></dt>
<dd>use the default precision of the current type
(7 digits for decimal32, 16 digits for decimal64 or 34 digits for decimal128)<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".precision32"></span><div class="quickindex" id="quickindex.precision32"></div><span class="def-anchor" id="precision32"></span><code class="ddoc_psymbol">precision32</code></em></dt>
<dd>use 32 bits precision (7 digits)<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".precision64"></span><div class="quickindex" id="quickindex.precision64"></div><span class="def-anchor" id="precision64"></span><code class="ddoc_psymbol">precision64</code></em></dt>
<dd>use 64 bits precision (16 digits)<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".precision128"></span><div class="quickindex" id="quickindex.precision128"></div><span class="def-anchor" id="precision128"></span><code class="ddoc_psymbol">precision128</code></em></dt>
<dd>use 128 bits precision (34 digits)<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl"></span><div class="quickindex" id="quickindex.DecimalControl"></div>struct <span class="def-anchor" id="DecimalControl"></span><code class="ddoc_psymbol">DecimalControl</code>;
</em></dt>
<dd>Container for decimal context control, provides methods to alter exception handling,
    manually edit error flags, adjust arithmetic precision and rounding mode<br><br>

<dl><dt><em class="big"><span class="def-anchor" id=".DecimalControl.rounding"></span><div class="quickindex" id="quickindex.DecimalControl.rounding"></div>static RoundingMode <span class="def-anchor" id="rounding"></span><code class="ddoc_psymbol">rounding</code>;
</em></dt>
<dd>    Gets or sets the <span class="def-anchor" id="rounding"></span><code class="ddoc_psymbol">rounding</code> mode used when the result of an operation exceeds the decimal precision.
    See <a href="#.RoundingMode"><em class="tt">RoundingMode</em></a>&nbsp; for details.
<pre class="d_code">DecimalControl.<span class="d_psymbol">rounding</span> = RoundingMode.tiesToEven;
decimal32 d1 = 123456789;
<span class="d_keyword">assert</span>(d1 == 123456800);

DecimalControl.<span class="d_psymbol">rounding</span> = RoundingMode.towardNegative;
decimal32 d2 = 123456789;
<span class="d_keyword">assert</span>(d2 == 123456700);
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.precision"></span><div class="quickindex" id="quickindex.DecimalControl.precision"></div>static Precision <span class="def-anchor" id="precision"></span><code class="ddoc_psymbol">precision</code>;
</em></dt>
<dd>    Gets or sets the <span class="def-anchor" id="precision"></span><code class="ddoc_psymbol">precision</code> applied to peration results.
    See <a href="#.Precision"><em class="tt">Precision</em></a>&nbsp; for details.
<pre class="d_code">DecimalControl.<span class="d_psymbol">precision</span> = precisionDefault;
decimal32 d1 = 12345;
<span class="d_keyword">assert</span>(d1 == 12345);

DecimalControl.<span class="d_psymbol">precision</span> = 4;
decimal32 d2 = 12345;
<span class="d_keyword">assert</span>(d2 == 12350);
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.raiseFlags"></span><div class="quickindex" id="quickindex.DecimalControl.raiseFlags"></div>static @safe void <span class="def-anchor" id="raiseFlags"></span><code class="ddoc_psymbol">raiseFlags</code>(const ExceptionFlags <code class="ddoc_param">group</code>);
</em></dt>
<dd>    Sets specified error flags. Multiple errors may be ORed together.
<pre class="d_code">DecimalControl.<span class="d_psymbol">raiseFlags</span>(ExceptionFlags.overflow | ExceptionFlags.underflow);
<span class="d_keyword">assert</span> (DecimalControl.overflow);
<span class="d_keyword">assert</span> (DecimalControl.underflow);
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.resetFlags"></span><div class="quickindex" id="quickindex.DecimalControl.resetFlags"></div>static nothrow @nogc @safe void <span class="def-anchor" id="resetFlags"></span><code class="ddoc_psymbol">resetFlags</code>(const ExceptionFlags <code class="ddoc_param">group</code>);
<br>static nothrow @nogc @safe void <span class="def-anchor" id="resetFlags"></span><code class="ddoc_psymbol">resetFlags</code>();
</em></dt>
<dd>    Unsets specified error flags. Multiple errors may be ORed together.
<pre class="d_code">DecimalControl.<span class="d_psymbol">resetFlags</span>(ExceptionFlags.inexact);
<span class="d_keyword">assert</span>(!DecimalControl.inexact);
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.restoreFlags"></span><div class="quickindex" id="quickindex.DecimalControl.restoreFlags"></div>static nothrow @nogc @safe void <span class="def-anchor" id="restoreFlags"></span><code class="ddoc_psymbol">restoreFlags</code>(const ExceptionFlags <code class="ddoc_param">group</code>);
</em></dt>
<dd>    Enables specified error flags (<code class="ddoc_param">group</code>) without throwing corresponding exceptions.
<pre class="d_code">DecimalControl.<span class="d_psymbol">restoreFlags</span>(ExceptionFlags.underflow | ExceptionsFlags.inexact);
<span class="d_keyword">assert</span> (DecimalControl.testFlags(ExceptionFlags.underflow | ExceptionFlags.inexact));
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.hasFlags"></span><div class="quickindex" id="quickindex.DecimalControl.hasFlags"></div>static nothrow @nogc @safe bool <span class="def-anchor" id="hasFlags"></span><code class="ddoc_psymbol">hasFlags</code>(const ExceptionFlags <code class="ddoc_param">group</code>);
</em></dt>
<dd>    Checks if the specified error flags are set. Multiple exceptions may be ORed together.
<pre class="d_code">DecimalControl.raiseFlags(ExceptionFlags.overflow | ExceptionFlags.underflow | ExceptionFlags.inexact);
<span class="d_keyword">assert</span> (DecimalControl.<span class="d_psymbol">hasFlags</span>(ExceptionFlags.overflow | ExceptionFlags.inexact));
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.saveFlags"></span><div class="quickindex" id="quickindex.DecimalControl.saveFlags"></div>static nothrow @nogc @safe ExceptionFlags <span class="def-anchor" id="saveFlags"></span><code class="ddoc_psymbol">saveFlags</code>();
</em></dt>
<dd>    Returns the current set flags.
<pre class="d_code">DecimalControl.restoreFlags(ExceptionFlags.inexact);
<span class="d_keyword">assert</span> (DecimalControl.<span class="d_psymbol">saveFlags</span>() &amp; ExceptionFlags.inexact);
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.disableExceptions"></span><div class="quickindex" id="quickindex.DecimalControl.disableExceptions"></div>static nothrow @nogc @safe void <span class="def-anchor" id="disableExceptions"></span><code class="ddoc_psymbol">disableExceptions</code>(const ExceptionFlags <code class="ddoc_param">group</code>);
<br>static nothrow @nogc @safe void <span class="def-anchor" id="disableExceptions"></span><code class="ddoc_psymbol">disableExceptions</code>();
</em></dt>
<dd>    Disables specified exceptions. Multiple exceptions may be ORed together.
<pre class="d_code">DecimalControl.<span class="d_psymbol">disableExceptions</span>(ExceptionFlags.overflow);
<span class="d_keyword">auto</span> d = decimal64.max * decimal64.max;
<span class="d_keyword">assert</span> (DecimalControl.overflow);
<span class="d_keyword">assert</span> (isInfinity(d));
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.enableExceptions"></span><div class="quickindex" id="quickindex.DecimalControl.enableExceptions"></div>static nothrow @nogc @safe void <span class="def-anchor" id="enableExceptions"></span><code class="ddoc_psymbol">enableExceptions</code>(const ExceptionFlags <code class="ddoc_param">group</code>);
</em></dt>
<dd>    Enables specified exceptions. Multiple exceptions may be ORed together.
<pre class="d_code">DecimalControl.<span class="d_psymbol">enableExceptions</span>(ExceptionFlags.overflow);
<span class="d_keyword">try</span>
{
    <span class="d_keyword">auto</span> d = decimal64.max * 2;
}
<span class="d_keyword">catch</span> (OverflowException)
{
    writeln(<span class="d_string">"Overflow error"</span>)
}
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.enabledExceptions"></span><div class="quickindex" id="quickindex.DecimalControl.enabledExceptions"></div>static nothrow @nogc @property @safe ExceptionFlags <span class="def-anchor" id="enabledExceptions"></span><code class="ddoc_psymbol">enabledExceptions</code>();
</em></dt>
<dd>    Extracts current enabled exceptions.
<pre class="d_code"><span class="d_keyword">auto</span> saved = DecimalControl.<span class="d_psymbol">enabledExceptions</span>;
DecimalControl.disableExceptions(ExceptionFlags.all);
DecimalControl.enableExceptions(saved);
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.invalidOperation"></span><div class="quickindex" id="quickindex.DecimalControl.invalidOperation"></div>static nothrow @nogc @property @safe bool <span class="def-anchor" id="invalidOperation"></span><code class="ddoc_psymbol">invalidOperation</code>();
<br><span class="def-anchor" id=".DecimalControl.divisionByZero"></span><div class="quickindex" id="quickindex.DecimalControl.divisionByZero"></div>static nothrow @nogc @property @safe bool <span class="def-anchor" id="divisionByZero"></span><code class="ddoc_psymbol">divisionByZero</code>();
<br><span class="def-anchor" id=".DecimalControl.overflow"></span><div class="quickindex" id="quickindex.DecimalControl.overflow"></div>static nothrow @nogc @property @safe bool <span class="def-anchor" id="overflow"></span><code class="ddoc_psymbol">overflow</code>();
<br><span class="def-anchor" id=".DecimalControl.underflow"></span><div class="quickindex" id="quickindex.DecimalControl.underflow"></div>static nothrow @nogc @property @safe bool <span class="def-anchor" id="underflow"></span><code class="ddoc_psymbol">underflow</code>();
<br><span class="def-anchor" id=".DecimalControl.inexact"></span><div class="quickindex" id="quickindex.DecimalControl.inexact"></div>static nothrow @nogc @property @safe bool <span class="def-anchor" id="inexact"></span><code class="ddoc_psymbol">inexact</code>();
</em></dt>
<dd>    IEEE decimal context errors. By default, no error is set.
<pre class="d_code">DecimalControl.disableExceptions(ExceptionFlags.all);
decimal32 uninitialized;
decimal64 d = decimal64.max * 2;
decimal32 e = uninitialized + 5.0;
<span class="d_keyword">assert</span>(DecimalControl.<span class="d_psymbol">overflow</span>);
<span class="d_keyword">assert</span>(DecimalControl.<span class="d_psymbol">invalidOperation</span>);
</pre>
<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.is754version1985"></span><div class="quickindex" id="quickindex.DecimalControl.is754version1985"></div>enum bool <span class="def-anchor" id="is754version1985"></span><code class="ddoc_psymbol">is754version1985</code>;
</em></dt>
<dd><code class="ddoc_keyword">true</code> if this programming environment conforms to IEEE 754-1985<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalControl.is754version2008"></span><div class="quickindex" id="quickindex.DecimalControl.is754version2008"></div>enum bool <span class="def-anchor" id="is754version2008"></span><code class="ddoc_psymbol">is754version2008</code>;
</em></dt>
<dd><code class="ddoc_keyword">true</code> if this programming environment conforms to IEEE 754-2008<br><br>

</dd>
</dl>
</dd>
<dt><em class="big"><span class="def-anchor" id=".acos"></span><div class="quickindex" id="quickindex.acos"></div>D <span class="def-anchor" id="acos"></span><code class="ddoc_psymbol">acos</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the arc cosine of <code class="ddoc_param">x</code>, returning a value ranging from 0 to π.
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or |<code class="ddoc_param">x</code>| &gt; 1.0</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="acos"></span><code class="ddoc_psymbol">acos</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>-1.0</td> <td>π</td></tr>
    <tr><td>+1.0</td> <td>+0.0</td></tr>
    <tr><td>&lt; -1.0</td> <td>NaN</td></tr>
    <tr><td>&gt; +1.0</td> <td>NaN</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 0;
<span class="d_keyword">assert</span>(<span class="d_psymbol">acos</span>(<span class="d_param">x</span>) == decimal32.PI_2);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".acosh"></span><div class="quickindex" id="quickindex.acosh"></div>D <span class="def-anchor" id="acosh"></span><code class="ddoc_psymbol">acosh</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the inverse hyperbolic cosine of <code class="ddoc_param">x</code>
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; 1.0</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="acosh"></span><code class="ddoc_psymbol">acosh</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>+1.0</td> <td>+0.0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
    <tr><td>&lt; 1.0</td> <td>NaN</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 1;
<span class="d_keyword">assert</span> (<span class="d_psymbol">acosh</span>(<span class="d_param">x</span>) == 0);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".asin"></span><div class="quickindex" id="quickindex.asin"></div>D <span class="def-anchor" id="asin"></span><code class="ddoc_psymbol">asin</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the arc sine of <code class="ddoc_param">x</code>, returning a value ranging from -π/2 to +π/2.
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or |<code class="ddoc_param">x</code>| &gt; 1.0</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="asin"></span><code class="ddoc_psymbol">asin</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>-1.0</td> <td>-π/2</td></tr>
    <tr><td>+1.0</td> <td>+π/2</td></tr>
    <tr><td>&lt; -1.0</td> <td>NaN</td></tr>
    <tr><td>&gt; +1.0</td> <td>NaN</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 1;
<span class="d_keyword">assert</span>(<span class="d_psymbol">asin</span>(<span class="d_param">x</span>) == decimal32.PI_2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">asin</span>(-<span class="d_param">x</span>) == -decimal32.PI_2);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".asinh"></span><div class="quickindex" id="quickindex.asinh"></div>D <span class="def-anchor" id="asinh"></span><code class="ddoc_psymbol">asinh</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the inverse hyperbolic sine of <code class="ddoc_param">x</code>
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>the result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="asinh"></span><code class="ddoc_psymbol">asinh</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 0;
<span class="d_keyword">assert</span> (<span class="d_psymbol">asinh</span>(<span class="d_param">x</span>) == 0);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".atan"></span><div class="quickindex" id="quickindex.atan"></div>D <span class="def-anchor" id="atan"></span><code class="ddoc_psymbol">atan</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the arc tangent of <code class="ddoc_param">x</code>, returning a value ranging from -π/2 to π/2.
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>the result is too small to be represented</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="atan"></span><code class="ddoc_psymbol">atan</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>±π/2</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 radians = 1;
<span class="d_keyword">assert</span>(<span class="d_psymbol">atan</span>(radians) == decimal32.PI_4);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".atan2"></span><div class="quickindex" id="quickindex.atan2"></div>auto <span class="def-anchor" id="atan2"></span><code class="ddoc_psymbol">atan2</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">y</code>, auto ref const D2 <code class="ddoc_param">x</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Calculates the arc tangent of <code class="ddoc_param">y</code> / <code class="ddoc_param">x</code>, returning a value ranging from -π to π.
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>the result is too small to be represented</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="atan2"></span><code class="ddoc_psymbol">atan2</code>(<code class="ddoc_param">y</code>, <code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>-0.0</td> <td>±π</td></tr>
    <tr><td>±0.0</td> <td>+0.0</td> <td>±0.0</td></tr>
    <tr><td>±0.0</td> <td>&lt;0.0</td> <td>±π</td></tr>
    <tr><td>±0.0</td> <td>&gt;0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>-∞</td> <td>±3π/4</td></tr>
    <tr><td>±∞</td> <td>+∞</td> <td>±π/4</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>±π/2</td></tr>
    <tr><td>any</td> <td>-∞</td> <td>±π</td></tr>
    <tr><td>any</td> <td>+∞</td> <td>±0.0</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">y</span> = 10;
decimal32 <span class="d_param">x</span> = 0;
<span class="d_keyword">assert</span> (<span class="d_psymbol">atan2</span>(<span class="d_param">y</span>, <span class="d_param">x</span>) == decimal32.PI_2);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".atan2pi"></span><div class="quickindex" id="quickindex.atan2pi"></div>auto <span class="def-anchor" id="atan2pi"></span><code class="ddoc_psymbol">atan2pi</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">y</code>, auto ref const D2 <code class="ddoc_param">x</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Calculates the arc tangent of <code class="ddoc_param">y</code> / <code class="ddoc_param">x</code> divided by π, returning a value ranging from -1 to 1.
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>the result is too small to be represented</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="atan2pi"></span><code class="ddoc_psymbol">atan2pi</code>(<code class="ddoc_param">y</code>, <code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>-0.0</td> <td>±1.0</td></tr>
    <tr><td>±0.0</td> <td>+0.0</td> <td>±0.0</td></tr>
    <tr><td>±0.0</td> <td>&lt;0.0</td> <td>±1.0</td></tr>
    <tr><td>±0.0</td> <td>&gt;0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>-∞</td> <td>±3/4</td></tr>
    <tr><td>±∞</td> <td>+∞</td> <td>±1/4</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>±1/2</td></tr>
    <tr><td>any</td> <td>-∞</td> <td>±1.0</td></tr>
    <tr><td>any</td> <td>+∞</td> <td>±0.0</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">y</span> = 10;
decimal32 <span class="d_param">x</span> = 0;
<span class="d_keyword">assert</span> (<span class="d_psymbol">atan2pi</span>(<span class="d_param">y</span>, <span class="d_param">x</span>) == decimal32(<span class="d_string">"0.5"</span>));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".atanh"></span><div class="quickindex" id="quickindex.atanh"></div>D <span class="def-anchor" id="atanh"></span><code class="ddoc_psymbol">atanh</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the inverse hyperbolic tangent of <code class="ddoc_param">x</code>
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or |<code class="ddoc_param">x</code>| &gt; 1.0</td></tr>
    <tr><td><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;</td>
         <td>|<code class="ddoc_param">x</code>| = 1.0</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>the result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="atanh"></span><code class="ddoc_psymbol">atanh</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±1.0</td> <td>±∞</td></tr>
    <tr><td>&gt;1.0</td> <td>NaN</td></tr>
    <tr><td>&lt;1.0</td> <td>NaN</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 0;
<span class="d_keyword">assert</span> (<span class="d_psymbol">atanh</span>(<span class="d_param">x</span>) == 0);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".atanpi"></span><div class="quickindex" id="quickindex.atanpi"></div>D <span class="def-anchor" id="atanpi"></span><code class="ddoc_psymbol">atanpi</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the arc tangent of <code class="ddoc_param">x</code> divided by π, returning a value ranging from -1/2 to 1/2.
<br><br>
<b>Exceptions</b><br><br>
<table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>the result is too small to be represented</td></tr>
</table>
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">atan(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>±1/2</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 radians = 1;
<span class="d_keyword">assert</span> (<span class="d_psymbol">atanpi</span>(radians) == decimal32(<span class="d_string">"0.25"</span>));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".cbrt"></span><div class="quickindex" id="quickindex.cbrt"></div>D <span class="def-anchor" id="cbrt"></span><code class="ddoc_psymbol">cbrt</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Computes the cubic root of <code class="ddoc_param">x</code>
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>cubic root of <code class="ddoc_param">x</code> is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="cbrt"></span><code class="ddoc_psymbol">cbrt</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 27;
<span class="d_keyword">assert</span> (<span class="d_psymbol">cbrt</span>(<span class="d_param">x</span>) == 3);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".ceil"></span><div class="quickindex" id="quickindex.ceil"></div>D <span class="def-anchor" id="ceil"></span><code class="ddoc_psymbol">ceil</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded upward to the next integer (toward positive infinity).
This operation is silent, doesn't throw any exception.
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="ceil"></span><code class="ddoc_psymbol">ceil</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">ceil</span>(decimal32(<span class="d_string">"123.456"</span>)) == 124);
<span class="d_keyword">assert</span> (<span class="d_psymbol">ceil</span>(decimal32(<span class="d_string">"-123.456"</span>)) == -123);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".cmp"></span><div class="quickindex" id="quickindex.cmp"></div>int <span class="def-anchor" id="cmp"></span><code class="ddoc_psymbol">cmp</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Defines a total order on all decimal values.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D1 <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
<tr><td>D2 <code class="ddoc_param">y</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
            -1 if <code class="ddoc_param">x</code> precedes <code class="ddoc_param">y</code>, 0 if <code class="ddoc_param">x</code> is equal to <code class="ddoc_param">y</code>, +1 if <code class="ddoc_param">x</code> follows <code class="ddoc_param">y</code>
<br><br><b>Notes</b><br><br>
    The total order is defined as:<br/>
    - -sNaN &lt; -NaN &lt; -infinity &lt; -finite &lt; -0.0 &lt; +0.0 &lt; +finite &lt; +infinity &lt; +NaN &lt; +sNaN<br/>
    - for two NaN values the total order is defined based on the payload<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">cmp</span>(-decimal32.nan, decimal64.max) == -1);
<span class="d_keyword">assert</span> (<span class="d_psymbol">cmp</span>(decimal32.max, decimal128.min_normal) == 1);
<span class="d_keyword">assert</span> (<span class="d_psymbol">cmp</span>(decimal64(0), -decimal64(0)) == 1);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".compound"></span><div class="quickindex" id="quickindex.compound"></div>auto <span class="def-anchor" id="compound"></span><code class="ddoc_psymbol">compound</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const int <code class="ddoc_param">n</code>) if (isDecimal!D);
</em></dt>
<dd>Computes (1 + <code class="ddoc_param">x</code>)<sup><code class="ddoc_param">n</code></sup> where <code class="ddoc_param">n</code> is an integer
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; -1.0</td></tr>
    <tr><td><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> = -1.0 and <code class="ddoc_param">n</code> &lt; 0</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">n</code></th> <th scope="col"><span class="def-anchor" id="compound"></span><code class="ddoc_psymbol">compound</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">n</code>)</th></tr>
    <tr><td>sNaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>0</td> <td>+1.0</td></tr>
    <tr><td>-1.0</td> <td>&lt;0</td> <td>+∞</td></tr>
    <tr><td>-1.0</td> <td>&gt;0</td> <td>+0.0</td></tr>
    <tr><td>+∞</td> <td>any</td> <td>+∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = <span class="d_string">"0.2"</span>;
<span class="d_keyword">assert</span> (<span class="d_psymbol">compound</span>(<span class="d_param">x</span>, 2) == decimal32(<span class="d_string">"1.44"</span>));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".copysign"></span><div class="quickindex" id="quickindex.copysign"></div>D1 <span class="def-anchor" id="copysign"></span><code class="ddoc_psymbol">copysign</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">to</code>, auto ref const D2 <code class="ddoc_param">from</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Copies the sign of a decimal value to another.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D1 <code class="ddoc_param">to</code></td>
<td>a decimal value <code class="ddoc_param">to</code> copy</td></tr>
<tr><td>D2 <code class="ddoc_param">from</code></td>
<td>a decimal value <code class="ddoc_param">from</code> which the sign is copied</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_param">to</code> with the sign of <code class="ddoc_param">from</code><br><br><b>Examples:</b><br>
        <pre class="d_code">decimal32 negative = -decimal32.min_normal;
decimal64 test = decimal64.max;
<span class="d_keyword">assert</span>(<span class="d_psymbol">copysign</span>(test, negative) == -decimal64.max);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".cos"></span><div class="quickindex" id="quickindex.cos"></div>D <span class="def-anchor" id="cos"></span><code class="ddoc_psymbol">cos</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns cosine of <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or ±∞</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="cos"></span><code class="ddoc_psymbol">cos</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>+1.0</td></tr>
    <tr><td>π/6</td> <td>+√3/2</td></tr>
    <tr><td>π/4</td> <td>+√2/2</td></tr>
    <tr><td>π/3</td> <td>+0.5</td></tr>
    <tr><td>π/2</td> <td>+0.0</td></tr>
    <tr><td>2π/3</td> <td>-0.5</td></tr>
    <tr><td>3π/4</td> <td>-√2/2</td></tr>
    <tr><td>5π/6</td> <td>-√3/2</td></tr>
    <tr><td>π</td> <td>-1.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".cosh"></span><div class="quickindex" id="quickindex.cosh"></div>D <span class="def-anchor" id="cosh"></span><code class="ddoc_psymbol">cosh</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the hyperbolic cosine of <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="cosh"></span><code class="ddoc_psymbol">cosh</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>+∞</td></tr>
    <tr><td>±0.0</td> <td>+1.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".cospi"></span><div class="quickindex" id="quickindex.cospi"></div>D <span class="def-anchor" id="cospi"></span><code class="ddoc_psymbol">cospi</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns cosine of xπ.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or ±∞</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="cospi"></span><code class="ddoc_psymbol">cospi</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>+1.0</td></tr>
    <tr><td>1/6</td> <td>+√3/2</td></tr>
    <tr><td>1/4</td> <td>+√2/2</td></tr>
    <tr><td>1/3</td> <td>+0.5</td></tr>
    <tr><td>1/2</td> <td>+0.0</td></tr>
    <tr><td>2/3</td> <td>-0.5</td></tr>
    <tr><td>3/4</td> <td>-√2/2</td></tr>
    <tr><td>5/6</td> <td>-√3/2</td></tr>
    <tr><td>1.0</td> <td>-1.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalClass"></span><div class="quickindex" id="quickindex.DecimalClass"></div>enum <span class="def-anchor" id="DecimalClass"></span><code class="ddoc_psymbol">DecimalClass</code>: int;
</em></dt>
<dd>IEEE-754-2008 floating point categories<br><br>

<dl><dt><em class="big"><span class="def-anchor" id=".DecimalClass.signalingNaN"></span><div class="quickindex" id="quickindex.DecimalClass.signalingNaN"></div><span class="def-anchor" id="signalingNaN"></span><code class="ddoc_psymbol">signalingNaN</code><br><span class="def-anchor" id=".DecimalClass.quietNaN"></span><div class="quickindex" id="quickindex.DecimalClass.quietNaN"></div><span class="def-anchor" id="quietNaN"></span><code class="ddoc_psymbol">quietNaN</code></em></dt>
<dd>a signalling NaN represents most of the time an uninitialized variable;
a quiet NaN represents the result of an invalid operation<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalClass.negativeInfinity"></span><div class="quickindex" id="quickindex.DecimalClass.negativeInfinity"></div><span class="def-anchor" id="negativeInfinity"></span><code class="ddoc_psymbol">negativeInfinity</code><br><span class="def-anchor" id=".DecimalClass.positiveInfinity"></span><div class="quickindex" id="quickindex.DecimalClass.positiveInfinity"></div><span class="def-anchor" id="positiveInfinity"></span><code class="ddoc_psymbol">positiveInfinity</code></em></dt>
<dd>value represents infinity<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalClass.negativeNormal"></span><div class="quickindex" id="quickindex.DecimalClass.negativeNormal"></div><span class="def-anchor" id="negativeNormal"></span><code class="ddoc_psymbol">negativeNormal</code><br><span class="def-anchor" id=".DecimalClass.positiveNormal"></span><div class="quickindex" id="quickindex.DecimalClass.positiveNormal"></div><span class="def-anchor" id="positiveNormal"></span><code class="ddoc_psymbol">positiveNormal</code></em></dt>
<dd>value represents a normalized decimal value<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalClass.negativeSubnormal"></span><div class="quickindex" id="quickindex.DecimalClass.negativeSubnormal"></div><span class="def-anchor" id="negativeSubnormal"></span><code class="ddoc_psymbol">negativeSubnormal</code><br><span class="def-anchor" id=".DecimalClass.positiveSubnormal"></span><div class="quickindex" id="quickindex.DecimalClass.positiveSubnormal"></div><span class="def-anchor" id="positiveSubnormal"></span><code class="ddoc_psymbol">positiveSubnormal</code></em></dt>
<dd>value represents a subnormal decimal value<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".DecimalClass.negativeZero"></span><div class="quickindex" id="quickindex.DecimalClass.negativeZero"></div><span class="def-anchor" id="negativeZero"></span><code class="ddoc_psymbol">negativeZero</code><br><span class="def-anchor" id=".DecimalClass.positiveZero"></span><div class="quickindex" id="quickindex.DecimalClass.positiveZero"></div><span class="def-anchor" id="positiveZero"></span><code class="ddoc_psymbol">positiveZero</code></em></dt>
<dd>value is 0<br><br>

</dd>
</dl>
</dd>
<dt><em class="big"><span class="def-anchor" id=".decimalClass"></span><div class="quickindex" id="quickindex.decimalClass"></div>DecimalClass <span class="def-anchor" id="decimalClass"></span><code class="ddoc_psymbol">decimalClass</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the decimal class where <code class="ddoc_param">x</code> falls into.
This operation is silent, no exception flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        One of the members of <a href="#.DecimalClass"><em class="tt">DecimalClass</em></a>&nbsp; enumeration<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">decimalClass</span>(decimal32.nan) == DecimalClass.quietNaN);
<span class="d_keyword">assert</span>(<span class="d_psymbol">decimalClass</span>(decimal64.infinity) == DecimalClass.positiveInfinity);
<span class="d_keyword">assert</span>(<span class="d_psymbol">decimalClass</span>(decimal128.max) == DecimalClass.positiveNormal);
<span class="d_keyword">assert</span>(<span class="d_psymbol">decimalClass</span>(-decimal32.max) == DecimalClass.negativeNormal);
<span class="d_keyword">assert</span>(<span class="d_psymbol">decimalClass</span>(decimal128.epsilon) == DecimalClass.positiveNormal);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".dot"></span><div class="quickindex" id="quickindex.dot"></div>D <span class="def-anchor" id="dot"></span><code class="ddoc_psymbol">dot</code>(D)(const(D)[] <code class="ddoc_param">x</code>, const(D)[] <code class="ddoc_param">y</code>) if (isDecimal!D);
</em></dt>
<dd>Sums <code class="ddoc_param">x</code><sub>i</sub> * <code class="ddoc_param">y</code><sub>i</sub> using a higher precision, rounding only once at the end.
<br><br>
<b>Returns:</b><br>
        <code class="ddoc_param">x</code><sub>0</sub> * <code class="ddoc_param">y</code><sub>0</sub> + <code class="ddoc_param">x</code><sub>1</sub> * <code class="ddoc_param">y</code><sub>1</sub> + ... + <code class="ddoc_param">x</code><sub>n</sub> * <code class="ddoc_param">y</code><sub>n</sub>
<br><br><b>Notes</b><br><br>
If <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code> arrays are not of the same length, operation is performed for min(<code class="ddoc_param">x</code>.length, <code class="ddoc_param">y</code>.length);
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any combination of elements is (±∞, ±0.0) or (±0.0, ±∞)</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>there are two products resulting in infinities of different sign</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".exp"></span><div class="quickindex" id="quickindex.exp"></div>D <span class="def-anchor" id="exp"></span><code class="ddoc_psymbol">exp</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates e<sup><code class="ddoc_param">x</code></sup>
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>e<sup><code class="ddoc_param">x</code></sup> is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>e<sup><code class="ddoc_param">x</code></sup> is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="exp"></span><code class="ddoc_psymbol">exp</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>+1.0</td></tr>
    <tr><td>-∞</td> <td>0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 power = 1;
<span class="d_keyword">assert</span> (<span class="d_psymbol">exp</span>(power) == decimal32.E);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".exp10"></span><div class="quickindex" id="quickindex.exp10"></div>D <span class="def-anchor" id="exp10"></span><code class="ddoc_psymbol">exp10</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates 10<sup><code class="ddoc_param">x</code></sup>
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>10<sup><code class="ddoc_param">x</code></sup> is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>10<sup><code class="ddoc_param">x</code></sup> is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="exp10"></span><code class="ddoc_psymbol">exp10</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>+1.0</td></tr>
    <tr><td>-∞</td> <td>+0.0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
<span class="d_keyword">assert</span>(<span class="d_psymbol">exp10</span>(<span class="d_param">x</span>) == 1000);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".exp10m1"></span><div class="quickindex" id="quickindex.exp10m1"></div>D <span class="def-anchor" id="exp10m1"></span><code class="ddoc_psymbol">exp10m1</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates 10<sup><code class="ddoc_param">x</code></sup> - 1
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>10<sup><code class="ddoc_param">x</code></sup> - 1 is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>10<sup><code class="ddoc_param">x</code></sup> - 1 is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="exp10m1"></span><code class="ddoc_psymbol">exp10m1</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>-∞</td> <td>-1.0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
<span class="d_keyword">assert</span>(<span class="d_psymbol">exp10m1</span>(<span class="d_param">x</span>) == 999);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".exp2"></span><div class="quickindex" id="quickindex.exp2"></div>D <span class="def-anchor" id="exp2"></span><code class="ddoc_psymbol">exp2</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates 2<sup><code class="ddoc_param">x</code></sup>
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>2<sup><code class="ddoc_param">x</code></sup> is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>2<sup><code class="ddoc_param">x</code></sup> is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="exp2"></span><code class="ddoc_psymbol">exp2</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>+1.0</td></tr>
    <tr><td>-∞</td> <td>+0.0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
<span class="d_keyword">assert</span>(<span class="d_psymbol">exp2</span>(<span class="d_param">x</span>) == 8);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".exp2m1"></span><div class="quickindex" id="quickindex.exp2m1"></div>D <span class="def-anchor" id="exp2m1"></span><code class="ddoc_psymbol">exp2m1</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates 2<sup><code class="ddoc_param">x</code></sup> - 1
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>2<sup><code class="ddoc_param">x</code></sup> - 1 is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>2<sup><code class="ddoc_param">x</code></sup> - 1 is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="exp2m1"></span><code class="ddoc_psymbol">exp2m1</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>-∞</td> <td>-1.0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
<span class="d_keyword">assert</span>(<span class="d_psymbol">exp2m1</span>(<span class="d_param">x</span>) == 7);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".expm1"></span><div class="quickindex" id="quickindex.expm1"></div>D <span class="def-anchor" id="expm1"></span><code class="ddoc_psymbol">expm1</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates e<sup><code class="ddoc_param">x</code></sup> - 1
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>e<sup><code class="ddoc_param">x</code></sup> - 1 is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>e<sup><code class="ddoc_param">x</code></sup> - 1 is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="expm1"></span><code class="ddoc_psymbol">expm1</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>-∞</td> <td>-1.0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".fabs"></span><div class="quickindex" id="quickindex.fabs"></div>D <span class="def-anchor" id="fabs"></span><code class="ddoc_psymbol">fabs</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates |<code class="ddoc_param">x</code>|.
This operation is silent, no error flags are set and no exceptions are thrown.<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">fabs</span>(-decimal32.max) == decimal32.max);
<span class="d_keyword">assert</span>(<span class="d_psymbol">fabs</span>(decimal64.infinity) == decimal64.infinity);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".floor"></span><div class="quickindex" id="quickindex.floor"></div>D <span class="def-anchor" id="floor"></span><code class="ddoc_psymbol">floor</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded downward to the previous integer (toward negative infinity).
This operation is silent, doesn't throw any exception.
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="floor"></span><code class="ddoc_psymbol">floor</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">floor</span>(decimal32(<span class="d_string">"123.456"</span>)) == 123);
<span class="d_keyword">assert</span> (<span class="d_psymbol">floor</span>(decimal32(<span class="d_string">"-123.456"</span>)) == -124);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".fma"></span><div class="quickindex" id="quickindex.fma"></div>auto <span class="def-anchor" id="fma"></span><code class="ddoc_psymbol">fma</code>(D1, D2, D3)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>, auto ref const D3 <code class="ddoc_param">z</code>) if (isDecimal!(D1, D2, D3));
</em></dt>
<dd>Returns (<code class="ddoc_param">x</code> * <code class="ddoc_param">y</code>) + <code class="ddoc_param">z</code>, rounding only once according to the current precision and rounding mode
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code>, <code class="ddoc_param">y</code> or <code class="ddoc_param">z</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>) = (±∞, ±0.0) or (±0.0, ±∞)</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is infinite, <code class="ddoc_param">z</code> is infinite but has opposing sign</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><code class="ddoc_param">z</code></th> <th scope="col"><span class="def-anchor" id="fma"></span><code class="ddoc_psymbol">fma</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>, <code class="ddoc_param">z</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>any</td> <td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±0.0</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±∞</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>&gt;0.0</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>-∞</td> <td>&lt;0.0</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>-∞</td> <td>&lt;0.0</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>&gt;0.0</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>-∞</td> <td>&gt;0.0</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>&lt;0.0</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>&lt;0.0</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>-∞</td> <td>&gt;0.0</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>&gt;0.0</td> <td>+∞</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>&lt;0.0</td> <td>-∞</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>&lt;0.0</td> <td>-∞</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>&gt;0.0</td> <td>+∞</td> <td>-∞</td> <td>NaN</td></tr>
    <tr><td>&gt;0.0</td> <td>-∞</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>&lt;0.0</td> <td>+∞</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>&lt;0.0</td> <td>+∞</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>&gt;0.0</td> <td>-∞</td> <td>+∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>&gt;0.0</td> <td>+∞</td> <td>+∞</td></tr>
    <tr><td>-∞</td> <td>&lt;0.0</td> <td>+∞</td> <td>+∞</td></tr>
    <tr><td>+∞</td> <td>&lt;0.0</td> <td>-∞</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>&gt;0.0</td> <td>-∞</td> <td>-∞</td></tr>
    <tr><td>&gt;0.0</td> <td>+∞</td> <td>+∞</td> <td>+∞</td></tr>
    <tr><td>&lt;0.0</td> <td>-∞</td> <td>+∞</td> <td>+∞</td></tr>
    <tr><td>&lt;0.0</td> <td>+∞</td> <td>-∞</td> <td>-∞</td></tr>
    <tr><td>&gt;0.0</td> <td>-∞</td> <td>-∞</td> <td>-∞</td></tr>
    <tr><td>+∞</td> <td>&gt;0.0</td> <td>any</td> <td>+∞</td></tr>
    <tr><td>-∞</td> <td>&lt;0.0</td> <td>any</td> <td>+∞</td></tr>
    <tr><td>+∞</td> <td>&lt;0.0</td> <td>any</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>&gt;0.0</td> <td>any</td> <td>-∞</td></tr>
    <tr><td>&gt;0.0</td> <td>+∞</td> <td>any</td> <td>+∞</td></tr>
    <tr><td>&lt;0.0</td> <td>-∞</td> <td>any</td> <td>+∞</td></tr>
    <tr><td>&lt;0.0</td> <td>+∞</td> <td>any</td> <td>-∞</td></tr>
    <tr><td>&gt;0.0</td> <td>-∞</td> <td>any</td> <td>-∞</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 2;
decimal64 <span class="d_param">y</span> = 3;
decimal128 <span class="d_param">z</span> = 5;
<span class="d_keyword">assert</span> (<span class="d_psymbol">fma</span>(<span class="d_param">x</span>, <span class="d_param">y</span>, <span class="d_param">z</span>) == 11);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".fmax"></span><div class="quickindex" id="quickindex.fmax"></div>auto <span class="def-anchor" id="fmax"></span><code class="ddoc_psymbol">fmax</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!D1 &amp;&amp; isDecimal!D2);
</em></dt>
<dd>Returns the larger decimal value between <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="fmax"></span><code class="ddoc_psymbol">fmax</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td><code class="ddoc_param">y</code></td></tr>
    <tr><td>any</td> <td>NaN</td> <td><code class="ddoc_param">x</code></td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
decimal64 <span class="d_param">y</span> = -4;
<span class="d_keyword">assert</span> (<span class="d_psymbol">fmax</span>(<span class="d_param">x</span>, <span class="d_param">y</span>) == 3);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".fmaxAbs"></span><div class="quickindex" id="quickindex.fmaxAbs"></div>auto <span class="def-anchor" id="fmaxAbs"></span><code class="ddoc_psymbol">fmaxAbs</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!D1 &amp;&amp; isDecimal!D2);
</em></dt>
<dd>Returns the larger decimal value between absolutes of <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="fmaxAbs"></span><code class="ddoc_psymbol">fmaxAbs</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td><code class="ddoc_param">y</code></td></tr>
    <tr><td>any</td> <td>NaN</td> <td><code class="ddoc_param">x</code></td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
decimal64 <span class="d_param">y</span> = -4;
<span class="d_keyword">assert</span> (<span class="d_psymbol">fmaxAbs</span>(<span class="d_param">x</span>, <span class="d_param">y</span>) == -4);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".fmin"></span><div class="quickindex" id="quickindex.fmin"></div>auto <span class="def-anchor" id="fmin"></span><code class="ddoc_psymbol">fmin</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!D1 &amp;&amp; isDecimal!D2);
</em></dt>
<dd>Returns the smaller decimal value between <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="fmin"></span><code class="ddoc_psymbol">fmin</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td><code class="ddoc_param">y</code></td></tr>
    <tr><td>any</td> <td>NaN</td> <td><code class="ddoc_param">x</code></td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
decimal64 <span class="d_param">y</span> = -4;
<span class="d_keyword">assert</span> (<span class="d_psymbol">fmin</span>(<span class="d_param">x</span>, <span class="d_param">y</span>) == -4);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".fminAbs"></span><div class="quickindex" id="quickindex.fminAbs"></div>auto <span class="def-anchor" id="fminAbs"></span><code class="ddoc_psymbol">fminAbs</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!D1 &amp;&amp; isDecimal!D2);
</em></dt>
<dd>Returns the smaller decimal value between absolutes of <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="fminAbs"></span><code class="ddoc_psymbol">fminAbs</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td><code class="ddoc_param">y</code></td></tr>
    <tr><td>any</td> <td>NaN</td> <td><code class="ddoc_param">x</code></td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
decimal64 <span class="d_param">y</span> = -4;
<span class="d_keyword">assert</span> (<span class="d_psymbol">fminAbs</span>(<span class="d_param">x</span>, <span class="d_param">y</span>) == 3);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".fmod"></span><div class="quickindex" id="quickindex.fmod"></div>auto <span class="def-anchor" id="fmod"></span><code class="ddoc_psymbol">fmod</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>);
</em></dt>
<dd>Calculates the remainder of the division <code class="ddoc_param">x</code> / <code class="ddoc_param">y</code>
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D1 <code class="ddoc_param">x</code></td>
<td>dividend</td></tr>
<tr><td>D2 <code class="ddoc_param">y</code></td>
<td>divisor</td></tr>
</caption></table><br><b>Returns:</b><br>
        The value of <code class="ddoc_param">x</code> - n * <code class="ddoc_param">y</code>, where n is the quotient rounded toward zero of the division <code class="ddoc_param">x</code> / <code class="ddoc_param">y</code>
<br><br><b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN, <code class="ddoc_param">x</code> = ±∞, <code class="ddoc_param">y</code> = ±0.0</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">y</code> = 0.0</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="fmod"></span><code class="ddoc_psymbol">fmod</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>0.0</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>±∞</td> <td>NaN</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = <span class="d_string">"18.5"</span>;
decimal32 <span class="d_param">y</span> = <span class="d_string">"4.2"</span>;
<span class="d_keyword">assert</span> (<span class="d_psymbol">fmod</span>(<span class="d_param">x</span>, <span class="d_param">y</span>) == decimal32(<span class="d_string">"1.7"</span>));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".frexp"></span><div class="quickindex" id="quickindex.frexp"></div>D <span class="def-anchor" id="frexp"></span><code class="ddoc_psymbol">frexp</code>(D)(auto ref const D <code class="ddoc_param">x</code>, out int <code class="ddoc_param">y</code>);
</em></dt>
<dd>Separates decimal value into coefficient and exponent.
This operation is silent, doesn't throw any exception.
<br><br>
<b>Returns:</b><br>
        a result such as <code class="ddoc_param">x</code> = result * 10<sup><code class="ddoc_param">y</code></sup> and |result| &lt; 10.0
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="frexp"></span><code class="ddoc_psymbol">frexp</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>int.min</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>int.max</td> <td>+∞</td></tr>
    <tr><td>-∞</td> <td>int.min</td> <td>-∞</td></tr>
    <tr><td>±0.0</td> <td>0</td> <td>±0.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".getNaNPayload"></span><div class="quickindex" id="quickindex.getNaNPayload"></div>pure nothrow @nogc @safe uint <span class="def-anchor" id="getNaNPayload"></span><code class="ddoc_psymbol">getNaNPayload</code>(const decimal32 <code class="ddoc_param">x</code>);
<br>pure nothrow @nogc @safe ulong <span class="def-anchor" id="getNaNPayload"></span><code class="ddoc_psymbol">getNaNPayload</code>(const decimal64 <code class="ddoc_param">x</code>);
<br>pure nothrow @nogc @safe ulong <span class="def-anchor" id="getNaNPayload"></span><code class="ddoc_psymbol">getNaNPayload</code>(const decimal128 <code class="ddoc_param">x</code>, out ulong <code class="ddoc_param">payloadHi</code>);
</em></dt>
<dd>Extracts the current payload from a NaN value
<br><br>
<b>Note</b><br><br>
These functions do not check if <code class="ddoc_param">x</code> is truly a NaN value
    before extracting the payload. Using them on finite values will extract a part of the coefficient<br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = decimal32(<span class="d_string">"nan(123)"</span>);
decimal64 y = decimal64(<span class="d_string">"nan(456)"</span>);
decimal128 z = decimal128(<span class="d_string">"nan(789)"</span>);

<span class="d_keyword">assert</span> (<span class="d_psymbol">getNaNPayload</span>(<span class="d_param">x</span>) == 123);
<span class="d_keyword">assert</span> (<span class="d_psymbol">getNaNPayload</span>(y) == 456);
<span class="d_keyword">ulong</span> hi;
<span class="d_keyword">assert</span> (<span class="d_psymbol">getNaNPayload</span>(z, hi) == 789 &amp;&amp; hi == 0);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".hypot"></span><div class="quickindex" id="quickindex.hypot"></div>auto <span class="def-anchor" id="hypot"></span><code class="ddoc_psymbol">hypot</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!D1 &amp;&amp; isDecimal!D2);
</em></dt>
<dd>Calculates the length of the hypotenuse of a right-angled triangle with sides
of length <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code>. The hypotenuse is the value of the square root of the sums
of the squares of <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code>, <code class="ddoc_param">y</code> is signaling NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="hypot"></span><code class="ddoc_psymbol">hypot</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td> <td>nan</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>+∞</td></tr>
    <tr><td>any</td> <td>±∞</td> <td>+∞</td></tr>
    <tr><td>NaN</td> <td>any</td> <td>nan</td></tr>
    <tr><td>any</td> <td>NaN</td> <td>nan</td></tr>
    <tr><td>0.0</td> <td>any</td> <td><code class="ddoc_param">y</code></td></tr>
    <tr><td>any</td> <td>0.0</td> <td><code class="ddoc_param">x</code></td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 <span class="d_param">x</span> = 3;
decimal32 <span class="d_param">y</span> = 4;
<span class="d_keyword">assert</span> (<span class="d_psymbol">hypot</span>(<span class="d_param">x</span>, <span class="d_param">y</span>) == 5);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".ilogb"></span><div class="quickindex" id="quickindex.ilogb"></div>int <span class="def-anchor" id="ilogb"></span><code class="ddoc_psymbol">ilogb</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the 10-exponent of <code class="ddoc_param">x</code> as a signed integral value..
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is NaN, infinity or 0
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="ilogb"></span><code class="ddoc_psymbol">ilogb</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>int.min</td></tr>
    <tr><td>±∞</td> <td>int min + 1</td></tr>
    <tr><td>±0.0</td> <td>int.min + 2</td></tr>
    <tr><td>±1.0</td> <td>0</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">ilogb</span>(decimal32(1234)) == 3);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isCanonical"></span><div class="quickindex" id="quickindex.isCanonical"></div>bool <span class="def-anchor" id="isCanonical"></span><code class="ddoc_psymbol">isCanonical</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> is canonical.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is canonical, <code class="ddoc_keyword">false</code> otherwise
<br><br><b>Notes</b><br><br>
    A decimal value is considered canonical:<br/>
    - if the value is NaN, the payload must be less than 10 <sup>precision - 1</sup>;<br/>
    - if the value is infinity, no trailing bits are accepted;<br/>
    - if the value is finite, the coefficient must be less than 10 <sup>precision</sup>.<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isCanonical</span>(decimal32.max));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isCanonical</span>(decimal64.max));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isCanonical</span>(decimal32(<span class="d_string">"nan(0x3fffff)"</span>)));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isFinite"></span><div class="quickindex" id="quickindex.isFinite"></div>bool <span class="def-anchor" id="isFinite"></span><code class="ddoc_psymbol">isFinite</code>(D : Decimal!bits, int bits)(auto ref const D <code class="ddoc_param">x</code>);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> is a finite value.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is finite, <code class="ddoc_keyword">false</code> otherwise (NaN or infinity)<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isFinite</span>(decimal32.max));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinite</span>(decimal64.nan));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinite</span>(decimal128.infinity));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isIdentical"></span><div class="quickindex" id="quickindex.isIdentical"></div>bool <span class="def-anchor" id="isIdentical"></span><code class="ddoc_psymbol">isIdentical</code>(D)(auto ref const D <code class="ddoc_param">x</code>, auto ref const D <code class="ddoc_param">y</code>) if (isDecimal!D);
</em></dt>
<dd>Checks if two decimal values are identical
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
<tr><td>D <code class="ddoc_param">y</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> has the same internal representation as <code class="ddoc_param">y</code>
<br><br><b>Notes</b><br><br>
    Even if two decimal values are equal, their internal representation can be different:<br/>
    - NaN values must have the same sign and the same payload to be considered identical;
      NaN(12) is not identical to NaN(13)<br/>
    - Zero values must have the same sign and the same exponent to be considered identical;
      0 * 10<sup>3</sup> is not identical to 0 * 10<sup>5</sup><br/>
    - Finite values must be represented based on same exponent to be considered identical;
      123 * 10<sup>-3</sup> is not identical to 1.23 * 10<sup>-1</sup><br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">isIdentical</span>(decimal32.min_normal, decimal32.min_normal));
<span class="d_keyword">assert</span> (!<span class="d_psymbol">isIdentical</span>(decimal64(<span class="d_string">"nan"</span>), decimal64(<span class="d_string">"nan&lt;200&gt;"</span>)));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isInfinity"></span><div class="quickindex" id="quickindex.isInfinity"></div>bool <span class="def-anchor" id="isInfinity"></span><code class="ddoc_psymbol">isInfinity</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> represents infinity.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is infinite, <code class="ddoc_keyword">false</code> otherwise (NaN or any finite value)<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isInfinity</span>(decimal32.infinity));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isInfinity</span>(-decimal64.infinity));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isInfinity</span>(decimal128.nan));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isNaN"></span><div class="quickindex" id="quickindex.isNaN"></div>bool <span class="def-anchor" id="isNaN"></span><code class="ddoc_psymbol">isNaN</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> represents a NaN.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is NaN (quiet or signaling), <code class="ddoc_keyword">false</code> otherwise (any other value than NaN)<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isNaN</span>(decimal32()));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isNaN</span>(decimal64.nan));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isNaN</span>(decimal128.max));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isNormal"></span><div class="quickindex" id="quickindex.isNormal"></div>bool <span class="def-anchor" id="isNormal"></span><code class="ddoc_psymbol">isNormal</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> is normalized.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is normal, <code class="ddoc_keyword">false</code> otherwise (NaN, infinity, zero, subnormal)<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isNormal</span>(decimal32.max));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isNormal</span>(decimal64.nan));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isNormal</span>(decimal32(<span class="d_string">"0x1p-101"</span>)));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isPowerOf10"></span><div class="quickindex" id="quickindex.isPowerOf10"></div>bool <span class="def-anchor" id="isPowerOf10"></span><code class="ddoc_psymbol">isPowerOf10</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Checks whether a decimal value is a power of ten. This operation is silent,
no exception flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>any decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is power of ten, <code class="ddoc_keyword">false</code> otherwise (NaN, infinity, 0, negative)<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">isPowerOf10</span>(decimal32(<span class="d_string">"1000"</span>)));
<span class="d_keyword">assert</span> (<span class="d_psymbol">isPowerOf10</span>(decimal32(<span class="d_string">"0.001"</span>)));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isSignaling"></span><div class="quickindex" id="quickindex.isSignaling"></div>bool <span class="def-anchor" id="isSignaling"></span><code class="ddoc_psymbol">isSignaling</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> represents a signaling NaN.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is NaN and is signaling, <code class="ddoc_keyword">false</code> otherwise (quiet NaN, any other value)<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isSignaling</span>(decimal32()));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isSignaling</span>(decimal64.nan));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isSignaling</span>(decimal128.max));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isSubnormal"></span><div class="quickindex" id="quickindex.isSubnormal"></div>bool <span class="def-anchor" id="isSubnormal"></span><code class="ddoc_psymbol">isSubnormal</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> is subnormal (denormalized).
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is subnormal, <code class="ddoc_keyword">false</code> otherwise (NaN, infinity, zero, normal)<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isSubnormal</span>(decimal32(<span class="d_string">"0x1p-101"</span>)));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isSubnormal</span>(decimal32.max));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isSubnormal</span>(decimal64.nan));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isZero"></span><div class="quickindex" id="quickindex.isZero"></div>bool <span class="def-anchor" id="isZero"></span><code class="ddoc_psymbol">isZero</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> represents the value zero.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> is zero, <code class="ddoc_keyword">false</code> otherwise (any other value than zero)
<br><br><b>Standards:</b><br>
        If the internal representation of the decimal data type has a coefficient
    greater that 10<sup>precision</sup> - 1, is considered 0 according to
    IEEE standard.<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isZero</span>(decimal32(0)));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isZero</span>(decimal64.nan));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isZero</span>(decimal32(<span class="d_string">"0x9FFFFFp+10"</span>)));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isGreater"></span><div class="quickindex" id="quickindex.isGreater"></div>bool <span class="def-anchor" id="isGreater"></span><code class="ddoc_psymbol">isGreater</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isGreaterOrEqual"></span><div class="quickindex" id="quickindex.isGreaterOrEqual"></div>bool <span class="def-anchor" id="isGreaterOrEqual"></span><code class="ddoc_psymbol">isGreaterOrEqual</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isGreaterOrUnordered"></span><div class="quickindex" id="quickindex.isGreaterOrUnordered"></div>bool <span class="def-anchor" id="isGreaterOrUnordered"></span><code class="ddoc_psymbol">isGreaterOrUnordered</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isLess"></span><div class="quickindex" id="quickindex.isLess"></div>bool <span class="def-anchor" id="isLess"></span><code class="ddoc_psymbol">isLess</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isLessOrEqual"></span><div class="quickindex" id="quickindex.isLessOrEqual"></div>bool <span class="def-anchor" id="isLessOrEqual"></span><code class="ddoc_psymbol">isLessOrEqual</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isLessOrUnordered"></span><div class="quickindex" id="quickindex.isLessOrUnordered"></div>bool <span class="def-anchor" id="isLessOrUnordered"></span><code class="ddoc_psymbol">isLessOrUnordered</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isLessOrGreater"></span><div class="quickindex" id="quickindex.isLessOrGreater"></div>bool <span class="def-anchor" id="isLessOrGreater"></span><code class="ddoc_psymbol">isLessOrGreater</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isUnordered"></span><div class="quickindex" id="quickindex.isUnordered"></div>bool <span class="def-anchor" id="isUnordered"></span><code class="ddoc_psymbol">isUnordered</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Compares two decimal operands.
This operation is silent, no exception flags are set and no exceptions are thrown.
<br><br>
<b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if the specified condition is satisfied
<br><br><b>Notes</b><br><br>
By default, comparison operators will throw <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; or will
    set the <a href="#.ExceptionFlags.invalidOperation"><em class="tt">ExceptionFlags.invalidOperation</em></a>&nbsp; context flag if a trap is not set.
    The equivalent functions are silent and will not throw any exception (or will not set any flag)
    if a NaN value is encountered.<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">isUnordered</span>(decimal32.nan, decimal64.max));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isGreater</span>(decimal32.infinity, decimal128.max));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isGreaterOrEqual</span>(decimal32.infinity, decimal64.infinity));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isLess</span>(decimal64.max, decimal128.max));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isLessOrEqual</span>(decimal32.min_normal, decimal32.min_normal));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isLessOrGreater</span>(decimal128.max, -decimal128.max));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".isEqual"></span><div class="quickindex" id="quickindex.isEqual"></div>bool <span class="def-anchor" id="isEqual"></span><code class="ddoc_psymbol">isEqual</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".isNotEqual"></span><div class="quickindex" id="quickindex.isNotEqual"></div>bool <span class="def-anchor" id="isNotEqual"></span><code class="ddoc_psymbol">isNotEqual</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Compares two decimal operands for equality
<br><br>
<b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if the specified condition is satisfied, <code class="ddoc_keyword">false</code> otherwise or if any of the operands is NaN.
<br><br><b>Notes</b><br><br>
By default, <a href="#.Decimal.opEquals"><em class="tt">Decimal.opEquals</em></a>&nbsp; is silent, returning <code class="ddoc_keyword">false</code> if a NaN value is encountered.
    <span class="def-anchor" id="isEqual"></span><code class="ddoc_psymbol">isEqual</code> and <span class="def-anchor" id="isNotEqual"></span><code class="ddoc_psymbol">isNotEqual</code> will throw <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; or will
    set the <a href="#.ExceptionFlags.invalidOperation"><em class="tt">ExceptionFlags.invalidOperation</em></a>&nbsp; context flag if a trap is not set.<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">isEqual</span>(decimal32.max, decimal32.max));
<span class="d_keyword">assert</span> (<span class="d_psymbol">isNotEqual</span>(decimal32.max, decimal32.min_normal));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".ldexp"></span><div class="quickindex" id="quickindex.ldexp"></div>D <span class="def-anchor" id="ldexp"></span><code class="ddoc_psymbol">ldexp</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const int <code class="ddoc_param">n</code>) if (isDecimal!D);
</em></dt>
<dd>Computes <code class="ddoc_param">x</code> * 10<sup><code class="ddoc_param">n</code></sup>.
This operation is silent, doesn't throw any exception.
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">n</code></th> <th scope="col"><span class="def-anchor" id="ldexp"></span><code class="ddoc_psymbol">ldexp</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">n</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>±∞</td></tr>
    <tr><td>±0</td> <td>any</td> <td>±0</td></tr>
    <tr><td>any</td> <td>0</td> <td><code class="ddoc_param">x</code></td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".log"></span><div class="quickindex" id="quickindex.log"></div>D <span class="def-anchor" id="log"></span><code class="ddoc_psymbol">log</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the natural logarithm of <span class="def-anchor" id="log"></span><code class="ddoc_psymbol">log</code><sub>e</sub><code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; 0</td></tr>
    <tr><td><a href="#.DivisionByZero"><em class="tt">DivisionByZero</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is ±0.0</td></tr>
    <tr><td><a href="#.Underflow"><em class="tt">Underflow</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="log"></span><code class="ddoc_psymbol">log</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
    <tr><td>e</td> <td>+1.0</td></tr>
    <tr><td>&lt; 0.0</td> <td>NaN</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">log</span>(decimal32.E) == 1);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".log10"></span><div class="quickindex" id="quickindex.log10"></div>D <span class="def-anchor" id="log10"></span><code class="ddoc_psymbol">log10</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates log<sub>10</sub><code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; 0.0</td></tr>
    <tr><td><a href="#.DivisionByZero"><em class="tt">DivisionByZero</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is ±0.0</td></tr>
    <tr><td><a href="#.Underflow"><em class="tt">Underflow</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">log(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
    <tr><td>+10.0</td> <td>+1.0</td></tr>
    <tr><td>&lt; 0.0</td> <td>NaN</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".log10p1"></span><div class="quickindex" id="quickindex.log10p1"></div>D <span class="def-anchor" id="log10p1"></span><code class="ddoc_psymbol">log10p1</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates log<sub>10</sub>(<code class="ddoc_param">x</code> + 1).
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; 1.0</td></tr>
    <tr><td><a href="#.DivisionByZero"><em class="tt">DivisionByZero</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is -1.0</td></tr>
    <tr><td><a href="#.Underflow"><em class="tt">Underflow</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">log(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>-1.0</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
    <tr><td>+9.0</td> <td>+1.0</td></tr>
    <tr><td>&lt; -1.0</td> <td>NaN</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".log2"></span><div class="quickindex" id="quickindex.log2"></div>D <span class="def-anchor" id="log2"></span><code class="ddoc_psymbol">log2</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates log<sub>2</sub><code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; 0</td></tr>
    <tr><td><a href="#.DivisionByZero"><em class="tt">DivisionByZero</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is ±0.0</td></tr>
    <tr><td><a href="#.Underflow"><em class="tt">Underflow</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">log(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
    <tr><td>+2.0</td> <td>+1.0</td></tr>
    <tr><td>&lt; 0.0</td> <td>NaN</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".log2p1"></span><div class="quickindex" id="quickindex.log2p1"></div>D <span class="def-anchor" id="log2p1"></span><code class="ddoc_psymbol">log2p1</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates log<sub>2</sub>(<code class="ddoc_param">x</code> + 1).
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; 0</td></tr>
    <tr><td><a href="#.DivisionByZero"><em class="tt">DivisionByZero</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is -1.0</td></tr>
    <tr><td><a href="#.Underflow"><em class="tt">Underflow</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">log(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
    <tr><td>+1.0</td> <td>+1.0</td></tr>
    <tr><td>&lt; -1.0</td> <td>NaN</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".logp1"></span><div class="quickindex" id="quickindex.logp1"></div>D <span class="def-anchor" id="logp1"></span><code class="ddoc_psymbol">logp1</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates log<sub>e</sub>(<code class="ddoc_param">x</code> + 1).
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or <code class="ddoc_param">x</code> &lt; 0</td></tr>
    <tr><td><a href="#.DivisionByZero"><em class="tt">DivisionByZero</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is -1.0</td></tr>
    <tr><td><a href="#.Underflow"><em class="tt">Underflow</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">log(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>-∞</td></tr>
    <tr><td>-∞</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
    <tr><td>e - 1</td> <td>+1.0</td></tr>
    <tr><td>&lt; -1.0</td> <td>NaN</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".lrint"></span><div class="quickindex" id="quickindex.lrint"></div>long <span class="def-anchor" id="lrint"></span><code class="ddoc_psymbol">lrint</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isDecimal!D);
<br>long <span class="def-anchor" id="lrint"></span><code class="ddoc_psymbol">lrint</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded using the specified rounding mode.
If no rounding mode is specified the default context rounding mode is used instead.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is NaN or ±∞</td></tr>
   <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="lrint"></span><code class="ddoc_psymbol">lrint</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>0</td></tr>
    <tr><td>-∞</td> <td>long.min</td></tr>
    <tr><td>+∞</td> <td>long.max</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".lround"></span><div class="quickindex" id="quickindex.lround"></div>long <span class="def-anchor" id="lround"></span><code class="ddoc_psymbol">lround</code>(D)(auto ref const D <code class="ddoc_param">x</code>);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded away from zero.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is NaN or ±∞</td></tr>
   <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="lround"></span><code class="ddoc_psymbol">lround</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>0</td></tr>
    <tr><td>-∞</td> <td>long.min</td></tr>
    <tr><td>+∞</td> <td>long.max</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".modf"></span><div class="quickindex" id="quickindex.modf"></div>D <span class="def-anchor" id="modf"></span><code class="ddoc_psymbol">modf</code>(D)(auto ref const D <code class="ddoc_param">x</code>, ref D <code class="ddoc_param">y</code>) if (isDecimal!D);
</em></dt>
<dd>Splits <code class="ddoc_param">x</code> in integral and fractional part. This operation is silent, doesn't throw any exception
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>value to split</td></tr>
<tr><td>D <code class="ddoc_param">y</code></td>
<td>fractional part</td></tr>
</caption></table><br><b>Returns:</b><br>
        The value of <code class="ddoc_param">x</code> truncated toward zero.
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="modf"></span><code class="ddoc_psymbol">modf</code>(<code class="ddoc_param">x</code>)</th> <th scope="col"><code class="ddoc_param">y</code></th></tr>
    <tr><td>NaN</td> <td>NaN</td> <td>NaN</td></tr>
    <tr><td>0.0</td> <td>0.0</td> <td>0.0</td></tr>
    <tr><td>±∞</td> <td>0.0</td> <td>±∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".NaN"></span><div class="quickindex" id="quickindex.NaN"></div>pure nothrow @nogc @safe decimal32 <span class="def-anchor" id="NaN"></span><code class="ddoc_psymbol">NaN</code>(const uint <code class="ddoc_param">payload</code>);
<br>pure nothrow @nogc @safe decimal64 <span class="def-anchor" id="NaN"></span><code class="ddoc_psymbol">NaN</code>(const ulong <code class="ddoc_param">payload</code>);
<br>pure nothrow @nogc @safe decimal128 <span class="def-anchor" id="NaN"></span><code class="ddoc_psymbol">NaN</code>(const ulong <code class="ddoc_param">payloadHi</code>, const ulong <code class="ddoc_param">payloadLo</code>);
</em></dt>
<dd>Creates a quiet <span class="def-anchor" id="NaN"></span><code class="ddoc_psymbol">NaN</code> value using the specified <code class="ddoc_param">payload</code>
<br><br>
<b>Notes</b><br><br>
Payloads are masked to fit the current representation, being limited to mant_dig - 2;<br><br>
<b>Examples:</b><br>
        <pre class="d_code">decimal32 a = <span class="d_psymbol">NaN</span>(12345U);
decimal64 b = <span class="d_psymbol">NaN</span>(12345UL);
decimal128 c = <span class="d_psymbol">NaN</span>(123U, 456U);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".nearbyint"></span><div class="quickindex" id="quickindex.nearbyint"></div>D <span class="def-anchor" id="nearbyint"></span><code class="ddoc_psymbol">nearbyint</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isDecimal!D);
<br>D <span class="def-anchor" id="nearbyint"></span><code class="ddoc_psymbol">nearbyint</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded using the specified rounding mode.
If no rounding mode is specified the default context rounding mode is used instead.
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is signaling NaN
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="nearbyint"></span><code class="ddoc_psymbol">nearbyint</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">nearbyint</span>(decimal32(<span class="d_string">"1.2"</span>), RoundingMode.tiesToEven) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nearbyint</span>(decimal64(<span class="d_string">"2.7"</span>), RoundingMode.tiesToAway) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nearbyint</span>(decimal128(<span class="d_string">"-7.9"</span>), RoundingMode.towardZero) == -7);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nearbyint</span>(decimal128(<span class="d_string">"6.66"</span>)) == 7);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".nextDown"></span><div class="quickindex" id="quickindex.nextDown"></div>D <span class="def-anchor" id="nextDown"></span><code class="ddoc_psymbol">nextDown</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the previous decimal value before <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is signaling NaN
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="nextDown"></span><code class="ddoc_psymbol">nextDown</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>-∞</td> <td>-∞</td></tr>
    <tr><td>-max</td> <td>-∞</td></tr>
    <tr><td>±0.0</td> <td>-min_normal * epsilon</td></tr>
    <tr><td>+∞</td> <td>D.max</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".nextPow10"></span><div class="quickindex" id="quickindex.nextPow10"></div>D <span class="def-anchor" id="nextPow10"></span><code class="ddoc_psymbol">nextPow10</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Gives the next power of 10 after <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="nextPow10"></span><code class="ddoc_psymbol">nextPow10</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>+1.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".nextUp"></span><div class="quickindex" id="quickindex.nextUp"></div>D <span class="def-anchor" id="nextUp"></span><code class="ddoc_psymbol">nextUp</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the next representable decimal value after <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is signaling NaN
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="nextUp"></span><code class="ddoc_psymbol">nextUp</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>-∞</td> <td>-D.max</td></tr>
    <tr><td>±0.0</td> <td>D.min_normal * epsilon</td></tr>
    <tr><td>D.max</td> <td>+∞</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".poly"></span><div class="quickindex" id="quickindex.poly"></div>auto <span class="def-anchor" id="poly"></span><code class="ddoc_psymbol">poly</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, const(D2)[] <code class="ddoc_param">a</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Calculates <code class="ddoc_param">a</code><sub>0</sub> + <code class="ddoc_param">a</code><sub>1</sub><code class="ddoc_param">x</code> + <code class="ddoc_param">a</code><sub>2</sub><code class="ddoc_param">x</code><sup>2</sup> + .. + <code class="ddoc_param">a</code><sub>n</sub><code class="ddoc_param">x</code><sup>n</sup>
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or any <code class="ddoc_param">a</code><sub>i</sub> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is ±∞ and any <code class="ddoc_param">a</code><sub>i</sub> is ±0.0</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is ±0.0 and any <code class="ddoc_param">a</code><sub>i</sub> is ±∞</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".pow"></span><div class="quickindex" id="quickindex.pow"></div>D <span class="def-anchor" id="pow"></span><code class="ddoc_psymbol">pow</code>(D, T)(auto ref const D <code class="ddoc_param">x</code>, const T <code class="ddoc_param">n</code>) if (isDecimal!D &amp;&amp; isIntegral!T);
</em></dt>
<dd>Compute the value of <code class="ddoc_param">x</code><sup><code class="ddoc_param">n</code></sup>, where <code class="ddoc_param">n</code> is integral
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> = ±0.0 and <code class="ddoc_param">n</code> &lt; 0</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">n</code></th> <th scope="col"><span class="def-anchor" id="pow"></span><code class="ddoc_psymbol">pow</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">n</code>)</th> </tr>
    <tr><td>sNaN</td> <td>any</td> <td>NaN</td> </tr>
    <tr><td>any</td> <td>0</td> <td>+1.0</td> </tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>±∞</td> </tr>
    <tr><td>±0.0</td> <td>odd <code class="ddoc_param">n</code> &lt; 0</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>even <code class="ddoc_param">n</code> &lt; 0</td> <td>+∞</td> </tr>
    <tr><td>±0.0</td> <td>odd <code class="ddoc_param">n</code> &gt; 0</td> <td>±0.0</td>  </tr>
    <tr><td>±0.0</td> <td>even <code class="ddoc_param">n</code> &gt; 0</td> <td>+0.0</td> </tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".pow.2"></span><div class="quickindex" id="quickindex.pow.2"></div>auto <span class="def-anchor" id="pow"></span><code class="ddoc_psymbol">pow</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">x</code>);
</em></dt>
<dd>Compute the value of <code class="ddoc_param">x</code><sup>y</sup>
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> = ±0.0 and y &lt; 0.0</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">y</th> <th scope="col"><span class="def-anchor" id="pow"></span><code class="ddoc_psymbol">pow</code>(<code class="ddoc_param">x</code>, y)</th> </tr>
    <tr><td>sNaN</td> <td>any</td> <td>NaN</td> </tr>
    <tr><td>any</td> <td>0</td> <td>+1.0</td> </tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>±∞</td> </tr>
    <tr><td>±0.0</td> <td>odd n &lt; 0</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>even n &lt; 0</td> <td>+∞</td> </tr>
    <tr><td>±0.0</td> <td>odd n &gt; 0</td> <td>±0.0</td>  </tr>
    <tr><td>±0.0</td> <td>even n &gt; 0</td> <td>+0.0</td> </tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".quantize"></span><div class="quickindex" id="quickindex.quantize"></div>D1 <span class="def-anchor" id="quantize"></span><code class="ddoc_psymbol">quantize</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Express a value using another value exponent
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D1 <code class="ddoc_param">x</code></td>
<td>source value</td></tr>
<tr><td>D2 <code class="ddoc_param">y</code></td>
<td>value used as exponent source</td></tr>
</caption></table><br><b>Returns:</b><br>
        a value with the same numerical value as <code class="ddoc_param">x</code> but with the exponent of <code class="ddoc_param">y</code>
<br><br><b>Throws:</b><br>
        <br><br><b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>only one of <code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is ±∞</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="quantize"></span><code class="ddoc_psymbol">quantize</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±∞</td> <td>±∞</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>±∞</td> <td>NaN</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".remainder"></span><div class="quickindex" id="quickindex.remainder"></div>auto <span class="def-anchor" id="remainder"></span><code class="ddoc_psymbol">remainder</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>);
</em></dt>
<dd>Calculates the remainder of the division <code class="ddoc_param">x</code> / <code class="ddoc_param">y</code>
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D1 <code class="ddoc_param">x</code></td>
<td>dividend</td></tr>
<tr><td>D2 <code class="ddoc_param">y</code></td>
<td>divisor</td></tr>
</caption></table><br><b>Returns:</b><br>
        The value of <code class="ddoc_param">x</code> - n * <code class="ddoc_param">y</code>, where n is the quotient rounded to nearest even of the division <code class="ddoc_param">x</code> / <code class="ddoc_param">y</code>
<br><br><b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> or <code class="ddoc_param">y</code> is signaling NaN, <code class="ddoc_param">x</code> = ±∞, <code class="ddoc_param">y</code> = ±0.0</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">y</code> = 0.0</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">y</code></th> <th scope="col"><span class="def-anchor" id="remainder"></span><code class="ddoc_psymbol">remainder</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">y</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>0.0</td> <td>NaN</td></tr>
    <tr><td>any</td> <td>±∞</td> <td>NaN</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".rint"></span><div class="quickindex" id="quickindex.rint"></div>D <span class="def-anchor" id="rint"></span><code class="ddoc_psymbol">rint</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isDecimal!D);
<br>D <span class="def-anchor" id="rint"></span><code class="ddoc_psymbol">rint</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded using the specified rounding mode.
If no rounding mode is specified the default context rounding mode is used instead.
This function is similar to <a href="#.nearbyint"><em class="tt">nearbyint</em></a>&nbsp;, but if the rounded value is not exact it will throw
<a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="rint"></span><code class="ddoc_psymbol">rint</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
</table><br><br>
<b>Examples:</b><br>
        <pre class="d_code">DecimalControl.resetFlags(ExceptionFlags.inexact);
<span class="d_keyword">assert</span>(<span class="d_psymbol">rint</span>(decimal32(<span class="d_string">"9.9"</span>)) == 10);
<span class="d_keyword">assert</span>(DecimalControl.inexact);

DecimalControl.resetFlags(ExceptionFlags.inexact);
<span class="d_keyword">assert</span>(<span class="d_psymbol">rint</span>(decimal32(<span class="d_string">"9.0"</span>)) == 9);
<span class="d_keyword">assert</span>(!DecimalControl.inexact);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".rndtonl"></span><div class="quickindex" id="quickindex.rndtonl"></div>D <span class="def-anchor" id="rndtonl"></span><code class="ddoc_psymbol">rndtonl</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isDecimal!D);
<br>@safe D <span class="def-anchor" id="rndtonl"></span><code class="ddoc_psymbol">rndtonl</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded using the specified rounding mode.
If no rounding mode is specified the default context rounding mode is used instead.
If the value doesn't fit in a long data type <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp; is thrown.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result does not fit in a long data type</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="rndtonl"></span><code class="ddoc_psymbol">rndtonl</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".root"></span><div class="quickindex" id="quickindex.root"></div>D <span class="def-anchor" id="root"></span><code class="ddoc_psymbol">root</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const T <code class="ddoc_param">n</code>) if (isDecimal!D &amp; isIntegral!T);
</em></dt>
<dd>Compute the value of <code class="ddoc_param">x</code><sup>1/<code class="ddoc_param">n</code></sup>, where <code class="ddoc_param">n</code> is an integer
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> = ±0.0 and <code class="ddoc_param">n</code> &lt; 0.0</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented or <code class="ddoc_param">n</code> = -1</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented or <code class="ddoc_param">n</code> = -1</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">y</th> <th scope="col"><span class="def-anchor" id="root"></span><code class="ddoc_psymbol">root</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">n</code>)</th> </tr>
    <tr><td>sNaN</td> <td>any</td> <td>NaN</td> </tr>
    <tr><td>any</td> <td>0</td> <td>NaN</td> </tr>
    <tr><td>any</td> <td>-1</td> <td>NaN</td> </tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>±∞</td> </tr>
    <tr><td>±0.0</td> <td>odd <code class="ddoc_param">n</code> &lt; 0</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>even <code class="ddoc_param">n</code> &lt; 0</td> <td>+∞</td> </tr>
    <tr><td>±0.0</td> <td>odd <code class="ddoc_param">n</code> &gt; 0</td> <td>±0.0</td>  </tr>
    <tr><td>±0.0</td> <td>even <code class="ddoc_param">n</code> &gt; 0</td> <td>+0.0</td> </tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".round"></span><div class="quickindex" id="quickindex.round"></div>D <span class="def-anchor" id="round"></span><code class="ddoc_psymbol">round</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded away from zero.
This operation is silent, doesn't throw any exception.
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="round"></span><code class="ddoc_psymbol">round</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".rsqrt"></span><div class="quickindex" id="quickindex.rsqrt"></div>D <span class="def-anchor" id="rsqrt"></span><code class="ddoc_psymbol">rsqrt</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Computes the inverse square root of <code class="ddoc_param">x</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is signaling NaN or negative,
    <a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;, <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;,
    <a href="#.DivisionByZeroException"><em class="tt">DivisionByZeroException</em></a>&nbsp;
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="rsqrt"></span><code class="ddoc_psymbol">rsqrt</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>&lt; 0.0</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>NaN</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".sameQuantum"></span><div class="quickindex" id="quickindex.sameQuantum"></div>bool <span class="def-anchor" id="sameQuantum"></span><code class="ddoc_psymbol">sameQuantum</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Compares the exponents of two decimal values
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D1 <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
<tr><td>D2 <code class="ddoc_param">y</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if the internal representation of <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code> use the same exponent, <code class="ddoc_keyword">false</code> otherwise
<br><br><b>Notes</b><br><br>
Returns also <code class="ddoc_keyword">true</code> if both operands are NaN or both operands are infinite.<br><br>
<b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">sameQuantum</span>(decimal32.infinity, -decimal64.infinity));

<span class="d_keyword">auto</span> <span class="d_param">x</span> = decimal32(<span class="d_string">"123456e+23"</span>);
<span class="d_keyword">auto</span> <span class="d_param">y</span> = decimal64(<span class="d_string">"911911e+23"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">sameQuantum</span>(<span class="d_param">x</span>, <span class="d_param">y</span>));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".scalbn"></span><div class="quickindex" id="quickindex.scalbn"></div>D <span class="def-anchor" id="scalbn"></span><code class="ddoc_psymbol">scalbn</code>(D)(auto ref const D <code class="ddoc_param">x</code>, const int <code class="ddoc_param">n</code>) if (isDecimal!D);
</em></dt>
<dd><b>Returns:</b><br>
        <code class="ddoc_param">x</code> efficiently multiplied by 10<sup><code class="ddoc_param">n</code></sup>
<br><br><b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is signaling NaN, <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;,
    <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;, <a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><code class="ddoc_param">n</code></th> <th scope="col"><span class="def-anchor" id="scalbn"></span><code class="ddoc_psymbol">scalbn</code>(<code class="ddoc_param">x</code>, <code class="ddoc_param">n</code>)</th></tr>
    <tr><td>NaN</td> <td>any</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>any</td> <td>±∞</td></tr>
    <tr><td>±0</td> <td>any</td> <td>±0</td></tr>
    <tr><td>any</td> <td>0</td> <td><code class="ddoc_param">x</code></td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".scaledProd"></span><div class="quickindex" id="quickindex.scaledProd"></div>D <span class="def-anchor" id="scaledProd"></span><code class="ddoc_psymbol">scaledProd</code>(D)(const(D)[] <code class="ddoc_param">x</code>, out int <code class="ddoc_param">scale</code>) if (isDecimal!D);
</em></dt>
<dd>Multiplies elements of <code class="ddoc_param">x</code> using a higher precision, rounding only once at the end.
<br><br>
<b>Returns:</b><br>
        <code class="ddoc_param">x</code><sub>0</sub> * <code class="ddoc_param">x</code><sub>1</sub> * ... * <code class="ddoc_param">x</code><sub>n</sub>
<br><br><b>Notes</b><br><br>
To avoid overflow, an additional <code class="ddoc_param">scale</code> is provided that the final result is to be multiplied py 10<sup><code class="ddoc_param">scale</code></sup>
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>there is one infinite element and one 0.0 element</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".scaledProdSum"></span><div class="quickindex" id="quickindex.scaledProdSum"></div>D <span class="def-anchor" id="scaledProdSum"></span><code class="ddoc_psymbol">scaledProdSum</code>(D)(const(D)[] <code class="ddoc_param">x</code>, const(D)[] <code class="ddoc_param">y</code>, out int <code class="ddoc_param">scale</code>) if (isDecimal!D);
</em></dt>
<dd>Multiplies results of <code class="ddoc_param">x</code><sub>i</sub> + <code class="ddoc_param">y</code><sub>i</sub> using a higher precision, rounding only once at the end.
<br><br>
<b>Returns:</b><br>
        (<code class="ddoc_param">x</code><sub>0</sub> + <code class="ddoc_param">y</code><sub>0</sub>) * (<code class="ddoc_param">x</code><sub>1</sub> + <code class="ddoc_param">y</code><sub>1</sub>) * ... * (<code class="ddoc_param">x</code><sub>n</sub> + <code class="ddoc_param">y</code><sub>n</sub>)
<br><br><b>Notes</b><br><br>
To avoid overflow, an additional <code class="ddoc_param">scale</code> is provided that the final result is to be multiplied py 10<sup><code class="ddoc_param">scale</code></sup>.<br/>
    If <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code> arrays are not of the same length, operation is performed for min(<code class="ddoc_param">x</code>.length, <code class="ddoc_param">y</code>.length);
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code>[i] and <code class="ddoc_param">y</code>[i] are infinite and with different sign</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>there is one infinite element and one <code class="ddoc_param">x</code><sub>i</sub> + <code class="ddoc_param">y</code><sub>i</sub> == 0.0</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".scaledProdDiff"></span><div class="quickindex" id="quickindex.scaledProdDiff"></div>D <span class="def-anchor" id="scaledProdDiff"></span><code class="ddoc_psymbol">scaledProdDiff</code>(D)(const(D)[] <code class="ddoc_param">x</code>, const(D)[] <code class="ddoc_param">y</code>, out int <code class="ddoc_param">scale</code>) if (isDecimal!D);
</em></dt>
<dd>Multiplies results of <code class="ddoc_param">x</code><sub>i</sub> - <code class="ddoc_param">y</code><sub>i</sub> using a higher precision, rounding only once at the end.
<br><br>
<b>Returns:</b><br>
        (<code class="ddoc_param">x</code><sub>0</sub> - <code class="ddoc_param">y</code><sub>0</sub>) * (<code class="ddoc_param">x</code><sub>1</sub> - <code class="ddoc_param">y</code><sub>1</sub>) * ... * (<code class="ddoc_param">x</code><sub>n</sub> - <code class="ddoc_param">y</code><sub>n</sub>)
<br><br><b>Notes</b><br><br>
To avoid overflow, an additional <code class="ddoc_param">scale</code> is provided that the final result is to be multiplied py 10<sup><code class="ddoc_param">scale</code></sup></br>
    If <code class="ddoc_param">x</code> and <code class="ddoc_param">y</code> arrays are not of the same length, operation is performed for min(<code class="ddoc_param">x</code>.length, <code class="ddoc_param">y</code>.length);
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code><sub>i</sub> and <code class="ddoc_param">y</code><sub>i</sub> are infinite and with different sign</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>there is one infinite element and one <code class="ddoc_param">x</code><sub>i</sub> - <code class="ddoc_param">y</code><sub>i</sub> == 0.0</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".sgn"></span><div class="quickindex" id="quickindex.sgn"></div>pure nothrow @nogc @safe D <span class="def-anchor" id="sgn"></span><code class="ddoc_psymbol">sgn</code>(D : Decimal!bits, int bits)(auto ref const D <code class="ddoc_param">x</code>);
</em></dt>
<dd>Determines if <code class="ddoc_param">x</code> is negative
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
            -1.0 if <code class="ddoc_param">x</code> is negative, 0.0 if <code class="ddoc_param">x</code> is zero, 1.0 if <code class="ddoc_param">x</code> is positive<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">sgn</span>(decimal32.max) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">sgn</span>(-decimal32.max) == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">sgn</span>(decimal64(0)) == 0);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".signbit"></span><div class="quickindex" id="quickindex.signbit"></div>int <span class="def-anchor" id="signbit"></span><code class="ddoc_psymbol">signbit</code>(D : Decimal!bits, int bits)(auto ref const D <code class="ddoc_param">x</code>);
</em></dt>
<dd>Returns the sign bit of the specified value.
This operation is silent, no error flags are set and no exceptions are thrown.
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        1 if the sign bit is set, 0 otherwise<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">signbit</span>(-decimal32.infinity) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">signbit</span>(decimal64.min_normal) == 0);
<span class="d_keyword">assert</span>(<span class="d_psymbol">signbit</span>(-decimal128.max) == 1);
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".sin"></span><div class="quickindex" id="quickindex.sin"></div>D <span class="def-anchor" id="sin"></span><code class="ddoc_psymbol">sin</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns sine of <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or ±∞</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="sin"></span><code class="ddoc_psymbol">sin</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>NaN</td></tr>
    <tr><td>-π/2</td> <td>-1.0</td></tr>
    <tr><td>-π/3</td> <td>-√3/2</td></tr>
    <tr><td>-π/4</td> <td>-√2/2</td></tr>
    <tr><td>-π/6</td> <td>-0.5</td></tr>
    <tr><td>±0.0</td> <td>+0.0</td></tr>
    <tr><td>+π/6</td> <td>+0.5</td></tr>
    <tr><td>+π/4</td> <td>+√2/2</td></tr>
    <tr><td>+π/3</td> <td>+√3/2</td></tr>
    <tr><td>+π/2</td> <td>+1.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".sinh"></span><div class="quickindex" id="quickindex.sinh"></div>D <span class="def-anchor" id="sinh"></span><code class="ddoc_psymbol">sinh</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Calculates the hyperbolic sine of <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="sinh"></span><code class="ddoc_psymbol">sinh</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>+∞</td></tr>
    <tr><td>±0.0</td> <td>+0.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".sinPi"></span><div class="quickindex" id="quickindex.sinPi"></div>D <span class="def-anchor" id="sinPi"></span><code class="ddoc_psymbol">sinPi</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns sine of <code class="ddoc_param">x</code>*π.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or ±∞</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col">sin(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>NaN</td></tr>
    <tr><td>-1/2</td> <td>-1.0</td></tr>
    <tr><td>-1/3</td> <td>-√3/2</td></tr>
    <tr><td>-1/4</td> <td>-√2/2</td></tr>
    <tr><td>-1/6</td> <td>-0.5</td></tr>
    <tr><td>±0.0</td> <td>+0.0</td></tr>
    <tr><td>+1/6</td> <td>+0.5</td></tr>
    <tr><td>+1/4</td> <td>+√2/2</td></tr>
    <tr><td>+1/3</td> <td>+√3/2</td></tr>
    <tr><td>+1/2</td> <td>+1.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".sqrt"></span><div class="quickindex" id="quickindex.sqrt"></div>D <span class="def-anchor" id="sqrt"></span><code class="ddoc_psymbol">sqrt</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Computes the square root of <code class="ddoc_param">x</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is signaling NaN or negative,
    <a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;, <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="sqrt"></span><code class="ddoc_psymbol">sqrt</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>&lt; 0.0</td> <td>NaN</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
    <tr><td>+∞</td> <td>+∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".sum"></span><div class="quickindex" id="quickindex.sum"></div>D <span class="def-anchor" id="sum"></span><code class="ddoc_psymbol">sum</code>(D)(const(D)[] <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Sums elements of <code class="ddoc_param">x</code> using a higher precision, rounding only once at the end.</br>
<br><br>
<b>Returns:</b><br>
        <code class="ddoc_param">x</code><sub>0</sub> + <code class="ddoc_param">x</code><sub>1</sub> + ... + <code class="ddoc_param">x</code><sub>n</sub>
<br><br><b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>there are two infinite elements with different sign</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".sumAbs"></span><div class="quickindex" id="quickindex.sumAbs"></div>D <span class="def-anchor" id="sumAbs"></span><code class="ddoc_psymbol">sumAbs</code>(D)(const(D)[] <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Sums absolute elements of <code class="ddoc_param">x</code> using a higher precision, rounding only once at the end.
<br><br>
<b>Returns:</b><br>
        |<code class="ddoc_param">x</code><sub>0</sub>| + |<code class="ddoc_param">x</code><sub>1</sub>| + ... + |<code class="ddoc_param">x</code><sub>n</sub>|
<br><br><b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".sumSquare"></span><div class="quickindex" id="quickindex.sumSquare"></div>D <span class="def-anchor" id="sumSquare"></span><code class="ddoc_psymbol">sumSquare</code>(D)(const(D)[] <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Sums squares of elements of <code class="ddoc_param">x</code> using a higher precision, rounding only once at the end.
<br><br>
<b>Returns:</b><br>
        <code class="ddoc_param">x</code><sub>0</sub><sup>2</sup> + <code class="ddoc_param">x</code><sub>1</sub><sup>2</sup> + ... + <code class="ddoc_param">x</code><sub>n</sub><sup>2</sup>
<br><br><b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td>any <code class="ddoc_param">x</code> is signaling NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>result is inexact</td></tr>
</table><br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".tan"></span><div class="quickindex" id="quickindex.tan"></div>D <span class="def-anchor" id="tan"></span><code class="ddoc_psymbol">tan</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns tangent of <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN or ±∞</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="tan"></span><code class="ddoc_psymbol">tan</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>NaN</td></tr>
    <tr><td>-π/2</td> <td>-∞</td></tr>
    <tr><td>-π/3</td> <td>-√3</td></tr>
    <tr><td>-π/4</td> <td>-1.0</td></tr>
    <tr><td>-π/6</td> <td>-1/√3</td></tr>
    <tr><td>±0.0</td> <td>+0.0</td></tr>
    <tr><td>+π/6</td> <td>+1/√3</td></tr>
    <tr><td>+π/4</td> <td>+1.0</td></tr>
    <tr><td>+π/3</td> <td>+√3</td></tr>
    <tr><td>+π/2</td> <td>+∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".tanh"></span><div class="quickindex" id="quickindex.tanh"></div>D <span class="def-anchor" id="tanh"></span><code class="ddoc_psymbol">tanh</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns tangent of <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> is signaling NaN </td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
         <td>result is too small to be represented</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
         <td>result is too big to be represented</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td>the result is inexact</td></tr>
</table>
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="tanh"></span><code class="ddoc_psymbol">tanh</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±1.0</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".to"></span><div class="quickindex" id="quickindex.to"></div>T <span class="def-anchor" id="to"></span><code class="ddoc_psymbol">to</code>(T, D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isIntegral!T &amp;&amp; isDecimal!D);
</em></dt>
<dd>Converts <code class="ddoc_param">x</code> <span class="def-anchor" id="to"></span><code class="ddoc_psymbol">to</code> the specified integral type rounded if necessary by <code class="ddoc_param">mode</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is NaN,
    <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;, <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="to"></span><code class="ddoc_psymbol">to</code>!T(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>0</td></tr>
    <tr><td>+∞</td> <td>T.max</td></tr>
    <tr><td>-∞</td> <td>T.min</td></tr>
    <tr><td>±0.0</td> <td>0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".to.2"></span><div class="quickindex" id="quickindex.to.2"></div>F <span class="def-anchor" id="to"></span><code class="ddoc_psymbol">to</code>(F, D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isFloatingPoint!F &amp;&amp; isDecimal!D);
</em></dt>
<dd>Converts <code class="ddoc_param">x</code> <span class="def-anchor" id="to"></span><code class="ddoc_psymbol">to</code> the specified binary floating point type rounded if necessary by <code class="ddoc_param">mode</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;, <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".toDPD"></span><div class="quickindex" id="quickindex.toDPD"></div>pure nothrow @nogc @safe decimal32 <span class="def-anchor" id="toDPD"></span><code class="ddoc_psymbol">toDPD</code>(const decimal32 <code class="ddoc_param">x</code>);
<br>pure nothrow @nogc @safe decimal64 <span class="def-anchor" id="toDPD"></span><code class="ddoc_psymbol">toDPD</code>(const decimal64 <code class="ddoc_param">x</code>);
<br>pure nothrow @nogc @safe decimal128 <span class="def-anchor" id="toDPD"></span><code class="ddoc_psymbol">toDPD</code>(const decimal128 <code class="ddoc_param">x</code>);
<br><span class="def-anchor" id=".fromDPD"></span><div class="quickindex" id="quickindex.fromDPD"></div>pure nothrow @nogc @safe decimal32 <span class="def-anchor" id="fromDPD"></span><code class="ddoc_psymbol">fromDPD</code>(const decimal32 <code class="ddoc_param">x</code>);
<br>pure nothrow @nogc @safe decimal64 <span class="def-anchor" id="fromDPD"></span><code class="ddoc_psymbol">fromDPD</code>(const decimal64 <code class="ddoc_param">x</code>);
<br>pure nothrow @nogc @safe decimal128 <span class="def-anchor" id="fromDPD"></span><code class="ddoc_psymbol">fromDPD</code>(const decimal128 <code class="ddoc_param">x</code>);
</em></dt>
<dd>Converts the specified value from internal encoding from/to densely packed decimal encoding
<br><br>
<b>Notes</b><br><br>
Decimal values are represented internaly using
   <a href="https://en.wikipedia.org/wiki/Binary_Integer_Decimal">binary integer decimal encoding</a>,
   supported by Intel (BID).
   This function converts the specified value to/from
   <a href="https://en.wikipedia.org/wiki/Densely_Packed_Decimal">densely packed decimal encoding</a>,
   supported by IBM (DPD).
   Please note that a DPD encoded decimal cannot be passed to a function from this module, there is no way
   to determine if a decimal value is BID-encoded or DPD-encoded, all functions will assume a BID-encoding.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".toExact"></span><div class="quickindex" id="quickindex.toExact"></div>T <span class="def-anchor" id="toExact"></span><code class="ddoc_psymbol">toExact</code>(T, D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isIntegral!T &amp;&amp; isDecimal!D);
</em></dt>
<dd>Converts <code class="ddoc_param">x</code> to the specified integral type rounded if necessary by <code class="ddoc_param">mode</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp; if <code class="ddoc_param">x</code> is NaN,
<a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;
<a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;, <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption><tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="toExact"></span><code class="ddoc_psymbol">toExact</code>!T(<code class="ddoc_param">x</code>)</th></tr>
<tr><td>NaN</td> <td>0</td></tr>
<tr><td>+∞</td> <td>T.max</td></tr>
<tr><td>-∞</td> <td>T.min</td></tr>
<tr><td>±0.0</td> <td>0</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".toExact.2"></span><div class="quickindex" id="quickindex.toExact.2"></div>F <span class="def-anchor" id="toExact"></span><code class="ddoc_psymbol">toExact</code>(F, D)(auto ref const D <code class="ddoc_param">x</code>, const RoundingMode <code class="ddoc_param">mode</code>) if (isFloatingPoint!F &amp;&amp; isDecimal!D);
</em></dt>
<dd>Converts <code class="ddoc_param">x</code> to the specified binary floating point type rounded if necessary by <code class="ddoc_param">mode</code>
<br><br>
<b>Throws:</b><br>
        <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;, <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;,
    <a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".toMsCurrency"></span><div class="quickindex" id="quickindex.toMsCurrency"></div>long <span class="def-anchor" id="toMsCurrency"></span><code class="ddoc_psymbol">toMsCurrency</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
<br><span class="def-anchor" id=".fromMsCurrency"></span><div class="quickindex" id="quickindex.fromMsCurrency"></div>D <span class="def-anchor" id="fromMsCurrency"></span><code class="ddoc_psymbol">fromMsCurrency</code>(D)(const ulong <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Converts the specified value to/from Microsoft currency data type;
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
        <td><code class="ddoc_param">x</code> is NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
        <td><code class="ddoc_param">x</code> is infinite or outside the Currency limits</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
        <td><code class="ddoc_param">x</code> is too small to be represented as Currency</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> cannot be represented exactly</td></tr>
</table>
<br><br><b>Notes</b><br><br>
The Microsoft currency data type is stored as long
    always scaled by 10<sup>-4</sup><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".toMsDecimal"></span><div class="quickindex" id="quickindex.toMsDecimal"></div>DECIMAL <span class="def-anchor" id="toMsDecimal"></span><code class="ddoc_psymbol">toMsDecimal</code>(D)(auto ref const D <code class="ddoc_param">x</code>);
<br><span class="def-anchor" id=".fromMsDecimal"></span><div class="quickindex" id="quickindex.fromMsDecimal"></div>D <span class="def-anchor" id="fromMsDecimal"></span><code class="ddoc_psymbol">fromMsDecimal</code>(D)(auto ref const DECIMAL <code class="ddoc_param">x</code>);
</em></dt>
<dd>Converts the specified value to/from Microsoft decimal data type;
<br><br>
<b>Throws:</b><br>
        <table class="book"><caption></caption>    <tr><td><a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;</td>
        <td><code class="ddoc_param">x</code> is NaN</td></tr>
    <tr><td><a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;</td>
        <td><code class="ddoc_param">x</code> is infinite or outside the DECIMAL limits</td></tr>
    <tr><td><a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;</td>
        <td><code class="ddoc_param">x</code> is too small to be represented as DECIMAL</td></tr>
    <tr><td><a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;</td>
         <td><code class="ddoc_param">x</code> cannot be represented exactly</td></tr>
</table>
<br><br><b>Notes</b><br><br>
The Microsoft decimal data type is stored as a 96 bit integral
    scaled by a variable exponent between 10<sup>-28</sup> and 10<sup>0</sup>.<br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".totalOrder"></span><div class="quickindex" id="quickindex.totalOrder"></div>bool <span class="def-anchor" id="totalOrder"></span><code class="ddoc_psymbol">totalOrder</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
<br><span class="def-anchor" id=".totalOrderAbs"></span><div class="quickindex" id="quickindex.totalOrderAbs"></div>bool <span class="def-anchor" id="totalOrderAbs"></span><code class="ddoc_psymbol">totalOrderAbs</code>(D1, D2)(auto ref const D1 <code class="ddoc_param">x</code>, auto ref const D2 <code class="ddoc_param">y</code>) if (isDecimal!(D1, D2));
</em></dt>
<dd>Checks the order between two decimal values
<br><br>
<b>Params:</b><br>

<table cellspacing="0" cellpadding="5"><caption><tr><td>D1 <code class="ddoc_param">x</code></td>
<td>a decimal value</td></tr>
<tr><td>D2 <code class="ddoc_param">y</code></td>
<td>a decimal value</td></tr>
</caption></table><br><b>Returns:</b><br>
        <code class="ddoc_keyword">true</code> if <code class="ddoc_param">x</code> precedes <code class="ddoc_param">y</code>, <code class="ddoc_keyword">false</code> otherwise
<br><br><b>Notes</b><br><br>
<span class="def-anchor" id="totalOrderAbs"></span><code class="ddoc_psymbol">totalOrderAbs</code> checks the order between |<code class="ddoc_param">x</code>| and |<code class="ddoc_param">y</code>|
<br><br>
<b>See Also:</b><br>
        <a href="#.cmp"><em class="tt">cmp</em></a>&nbsp;<br><br><b>Examples:</b><br>
        <pre class="d_code"><span class="d_keyword">assert</span> (<span class="d_psymbol">totalOrder</span>(decimal32.min_normal, decimal64.max));
<span class="d_keyword">assert</span> (!<span class="d_psymbol">totalOrder</span>(decimal32.max, decimal128.min_normal));
<span class="d_keyword">assert</span> (<span class="d_psymbol">totalOrder</span>(-decimal64(0), decimal64(0)));
<span class="d_keyword">assert</span> (!<span class="d_psymbol">totalOrderAbs</span>(-decimal64(0), decimal64(0)));
</pre>
<br><br>
</dd>
<dt><em class="big"><span class="def-anchor" id=".trunc"></span><div class="quickindex" id="quickindex.trunc"></div>pure nothrow @nogc @safe D <span class="def-anchor" id="trunc"></span><code class="ddoc_psymbol">trunc</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Returns the value of <code class="ddoc_param">x</code> rounded up or down, depending on sign (toward zero).
This operation is silent, doesn't throw any exception.
<br><br>
<b>Special values</b><br><br>
<table class="book"><caption></caption><tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="trunc"></span><code class="ddoc_psymbol">trunc</code>(<code class="ddoc_param">x</code>)</th></tr>
<tr><td>NaN</td> <td>NaN</td></tr>
<tr><td>±0.0</td> <td>±0.0</td></tr>
<tr><td>±∞</td> <td>±∞</td></tr>
</table><br><br>

</dd>
<dt><em class="big"><span class="def-anchor" id=".truncPow10"></span><div class="quickindex" id="quickindex.truncPow10"></div>D <span class="def-anchor" id="truncPow10"></span><code class="ddoc_psymbol">truncPow10</code>(D)(auto ref const D <code class="ddoc_param">x</code>) if (isDecimal!D);
</em></dt>
<dd>Gives the previous power of 10 before <code class="ddoc_param">x</code>.
<br><br>
<b>Throws:</b><br>
        <a href="#.InvalidOperationException"><em class="tt">InvalidOperationException</em></a>&nbsp;,
    <a href="#.OverflowException"><em class="tt">OverflowException</em></a>&nbsp;,
    <a href="#.UnderflowException"><em class="tt">UnderflowException</em></a>&nbsp;,
    <a href="#.InexactException"><em class="tt">InexactException</em></a>&nbsp;
<br><br><b>Special values</b><br><br>
<table class="book"><caption></caption>    <tr><th scope="col"><code class="ddoc_param">x</code></th> <th scope="col"><span class="def-anchor" id="truncPow10"></span><code class="ddoc_psymbol">truncPow10</code>(<code class="ddoc_param">x</code>)</th></tr>
    <tr><td>NaN</td> <td>NaN</td></tr>
    <tr><td>±∞</td> <td>±∞</td></tr>
    <tr><td>±0.0</td> <td>±0.0</td></tr>
</table><br><br>

</dd>
</dl>

        <div class="smallprint" id="copyright">Copyright &copy; 1999-2018 by the <a href="https://dlang.org/foundation.html">D Language Foundation</a> | Page generated by
<a href="https://dlang.org/spec/ddoc.html">Ddoc</a> on Wed Jan 17 12:05:04 2018
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="https://dlang.org/js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="https://dlang.org/js/dlang.js"></script>
    
    <script type="text/javascript" src="https://dlang.org/js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="https://dlang.org/js/run.js"></script>


<script type="text/javascript" src="https://dlang.org/js/listanchors.js"></script>
<script type="text/javascript" src="https://dlang.org/js/show_contributors.js"></script>
<script type="text/javascript">jQuery(document).ready(listanchors);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>
